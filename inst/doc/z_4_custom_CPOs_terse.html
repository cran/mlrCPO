<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Martin Binder" />

<meta name="date" content="2024-02-20" />

<title>Building Custom CPOs (No Output)</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Building Custom CPOs (No Output)</h1>
<h4 class="author">Martin Binder</h4>
<h4 class="date">2024-02-20</h4>



<div id="cpo-vignette-navigation" class="section level4">
<h4>CPO Vignette Navigation</h4>
<ol style="list-style-type: decimal">
<li><a href="a_1_getting_started.html">1. First Steps</a> (<a href="z_1_getting_started_terse.html">compact version</a>)</li>
<li><a href="a_2_mlrCPO_core.html">mlrCPO Core</a> (<a href="z_2_mlrCPO_core_terse.html">compact version</a>)</li>
<li><a href="a_3_all_CPOs.html">CPOs Built Into mlrCPO</a> (<a href="z_3_all_CPOs_terse.html">compact version</a>)</li>
<li><a href="a_4_custom_CPOs.html">Building Custom CPOs</a> (compact
version)</li>
</ol>
<h2>
Table of Contents
</h2>
<div id="TOC">
<ul>
<li>
<a href="#intro">Intro</a>
</li>
<li>
<a href="#making-a-cpo">Making a CPO</a>
<ul>
<li>
<a href="#cpo-name">CPO name</a>
</li>
<li>
<a href="#cpo-parameters">CPO parameters</a>
</li>
<li>
<a href="#data-format">Data Format</a>
</li>
<li>
<a href="#properties">Properties</a>
<ul>
<li>
<a href="#property-checking-and-.sometimes-properties">Property Checking
and <code>.sometimes</code> Properties</a>
</li>
</ul>
</li>
<li>
<a href="#packages">Packages</a>
</li>
<li>
<a href="#transformation-functions">Transformation Functions</a>
<ul>
<li>
<a href="#functional-transformation">Functional Transformation</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#retrafoless-cpos">Retrafoless CPOs</a>
</li>
<li>
<a href="#feature-operation-cpos">Feature Operation CPOs</a>
<ul>
<li>
<a href="#makecpo"><code>makeCPO()</code></a>
<ul>
<li>
<a href="#functional-focpo">Functional FOCPO</a>
</li>
<li>
<a href="#stateless-focpo">Stateless FOCPO</a>
</li>
</ul>
</li>
<li>
<a href="#makecpoextendedtrafo"><code>makeCPOExtendedTrafo()</code></a>
<ul>
<li>
<a href="#functional-focpo">Functional FOCPO</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#target-operation-cpos">Target Operation CPOs</a>
<ul>
<li>
<a href="#task-type-and-conversion">Task Type and Conversion</a>
</li>
<li>
<a href="#predict.type"><code>predict.type</code></a>
</li>
<li>
<a href="#makecpotargetop"><code>makeCPOTargetOp()</code></a>
<ul>
<li>
<a href="#functional-tocpo">Functional TOCPO</a>
</li>
<li>
<a href="#constant-invert-tocpos">Constant Invert TOCPOs</a>
</li>
<li>
<a href="#functional-constant-invert-tocpo">Functional Constant Invert
TOCPO</a>
</li>
<li>
<a href="#stateless-tocpo">Stateless TOCPO</a>
</li>
</ul>
</li>
<li>
<a href="#makecpoextendedtargetop"><code>makeCPOExtendedTargetOp()</code></a>
</li>
</ul>
</li>
<li>
<a href="#postscriptum">Postscriptum</a>
</li>
</ul>
</div>
</div>
<div id="intro" class="section level2">
<h2>Intro</h2>
<p>The <a href="a_3_all_CPOs.html"><code>CPO</code>s built into
<code>mlrCPO</code></a> can be used for many different purposes, and can
be combined to form even more powerful transformation operations.
However, in some cases, it may be necessary to define new “custom”
<code>CPO</code>s that perform a certain task; either because a
preprocessing method is not (yet) defined as a builtin <code>CPO</code>,
or because some operation very specific to the task at hand needs to be
performed.</p>
<p>For this purpose, <code>mlrCPO</code> offers a very powerful
interface for the creation of new <code>CPO</code>s. The functions and
methods described here are also the methods used internally to create
<code>mlrCPO</code>’s builtin <code>CPO</code>s. Therefore, to learn the
art of defining <code>CPO</code>s, it is also possible to look at the <a href="https://github.com/mlr-org/mlrCPO/tree/master/R"><code>mlrCPO</code>
source tree</a> in files starting with “<code>CPO_</code>” for example
<code>CPO</code> definitions.</p>
<p>There are three types of <code>CPO</code>: “Feature Operation
<code>CPO</code>s” (<a href="#feature-operation-cpos"><strong>FOCPO</strong>s</a>) which are
only allowed to change feature columns of incoming data, and which are
the most common <code>CPO</code>s; “Target Operation <code>CPO</code>s”
(<a href="#target-operation-cpos"><strong>TOCPO</strong>s</a>) that
change only target columns, and “Retrafoless <code>CPO</code>s” (<a href="#retrafoless-cpos"><strong>ROCPO</strong>s</a>) that may add or
delete rows to a data set, but only during training. Conceptually,
ROCPOs are the simplest <code>CPO</code>s, followed by FOCPOs and the
even more complicated TOCPOs. The commonalities of all <code>CPO</code>
defining functions will be described first, followed by the different
<code>CPO</code> types in order of growing complexity.</p>
</div>
<div id="making-a-cpo" class="section level2">
<h2>Making a CPO</h2>
<p>To create a <code>CPOConstructor</code> that can then be used to
create a <code>CPO</code>, a <code>makeCPO*()</code> function needs to
be called. There are five functions of this kind, differing by what kind
of <code>CPO</code> they create and how much flexibility (at the cost of
simplicity) they offer the user:</p>
<table>
<thead>
<tr class="header">
<th><code>CPO</code> type</th>
<th><code>makeCPO*()</code> functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>FOCPO</td>
<td><code>makeCPO()</code>, <code>makeCPOExtendedTrafo()</code></td>
</tr>
<tr class="even">
<td>TOCPO</td>
<td><code>makeCPOTargetOp()</code>,
<code>makeCPOExtendedTargetOp()</code></td>
</tr>
<tr class="odd">
<td>ROCPO</td>
<td><code>makeCPORetrafoless()</code></td>
</tr>
</tbody>
</table>
<p>Each of these functions takes a “name” for the new <code>CPO</code>,
settings for the parameter set to be used, settings for the format in
which the data is supposed to be provided, data property settings, the
packages to load, <code>CPO</code> type specific settins, and finally
the transformation functions.</p>
<div id="cpo-name" class="section level3">
<h3>CPO name</h3>
<p>Each <code>CPO</code> has a “name” that is used for representation
when printing, and as the default prefix for hyperparameters.
<code>cpoPca</code>, for example, has the name “<code>pca</code>”:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!</span><span class="fu">cpoPca</span>()</span></code></pre></div>
<p>The name is set using the <strong><code>cpo.name</code></strong>
parameter of the <code>make*()</code> functions.</p>
</div>
<div id="cpo-parameters" class="section level3">
<h3>CPO parameters</h3>
<p>The <code>ParSet</code> used by the <code>CPO</code> are given as the
second <strong><code>par.set</code></strong> parameter. These parameters
must be either constructed using <code>makeParamSet()</code> from the
<code>ParamHelpers</code> package, or using the <code>pSS()</code>
function for a more concise <code>ParSet</code> definition. The given
parameters will then be the function parameters of the
<code>CPOConstructor</code>, and will by default be exported as
hyperparameters (prefixed with the <code>cpo.name</code>).</p>
<p>It is possible to use the default parameter values of the
<code>par.set</code> as defaults, or to give a
<strong><code>par.vals</code></strong> list of default values. If
<code>par.vals</code> is given, the defaults within <code>par.set</code>
are completely ignored. Parameters that have a default value are set to
this value upon construction if no value is given by the user.</p>
<p>Not all available parameters of a <code>CPO</code> need to be
exported as hyperparameters. <em>Which</em> parameters are exported can
be set during <code>CPO</code> construction, but the default exported
parameters can be set using <strong><code>export.params</code></strong>.
This can either be a <code>character</code> vector of the names of
parameters to export, or <code>TRUE</code> (default, export all) or
<code>FALSE</code> (no export).</p>
</div>
<div id="data-format" class="section level3">
<h3>Data Format</h3>
<p>Different <code>CPO</code> operations may want to operate on the data
in different forms: as a <code>Task</code>, as a <code>data.frame</code>
with or without the target column, etc. The <code>CPO</code> framework
can perform some conversion of data to fit different needs, which is set
up by the value of fthe <strong><code>dataformat</code></strong>
parameter, together with
<strong><code>dataformat.factor.with.ordered</code></strong>. While
<code>dataformat</code> has slightly different effects on different
<code>CPO</code> types, typically its values and effects are:</p>
<table>
<colgroup>
<col width="15%" />
<col width="84%" />
</colgroup>
<thead>
<tr class="header">
<th><code>dataformat</code></th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&quot;task&quot;</code></td>
<td>Data is given as a <code>Task</code>; if the data to be transformed
is a <code>data.frame</code>, it is converted to a <code>cluster</code>
task before handing it to the transformation functions.</td>
</tr>
<tr class="even">
<td><code>&quot;df.all&quot;</code></td>
<td>Data is given as a <code>data.frame</code>, with the target column
included.</td>
</tr>
<tr class="odd">
<td><code>&quot;df.features&quot;</code></td>
<td>Data is given as a <code>data.frame</code>, the target is given as a
separate <code>data.frame</code>.</td>
</tr>
<tr class="even">
<td><code>&quot;split&quot;</code></td>
<td>Data is given as a named list with slots <code>$numeric</code>,
<code>$factor</code>, <code>$ordered</code>, <code>$other</code>, each
of which contains a <code>data.frame</code> with the columns of the
respective type. If <code>dataformat.factor.with.ordered</code> is
<code>TRUE</code>, the <code>$ordered</code> slot is not present, and
ordered features are instead given to <code>$factor</code> as well.
Features that are not any of these types are given to
<code>&quot;other&quot;</code>. The target is given as a separate
<code>data.frame</code>.</td>
</tr>
<tr class="odd">
<td><code>&quot;factor&quot;</code>, <code>&quot;ordered&quot;</code>,
<code>&quot;numeric&quot;</code></td>
<td>Only the data from columns of the named type are given to the
transformatin functions as a <code>data.frame</code>. The target columns
are given as a separate <code>data.frame</code>.</td>
</tr>
</tbody>
</table>
<p>Another parameter influencing the data format is the
<strong><code>fix.factors</code></strong> flag which controls whether
factor levels of prediction data need to be set to be the same as during
training. If it is <code>TRUE</code>, previously unseen factor levels
are set to <code>NA</code> during prediction.</p>
</div>
<div id="properties" class="section level3">
<h3>Properties</h3>
<p><code>mlr</code> and <code>mlrCPO</code> make it possible to specify
what kind of data a <code>CPO</code> or a <code>Learner</code> can
handle. However, since <code>CPO</code>s may change data to be more or
less fitting for a certain <code>Learner</code>, a <code>CPO</code> must
announce not only what data it can handle, but also how it changes the
capabilities of the machine learning pipeline in which it is envolved.
During construction, four parameters related to properties can be
given.</p>
<p>The <strong><code>properties.data</code></strong> parameter defines
what properties of feature data the <code>CPO</code> can handle; it must
be a subset of <code>&quot;numerics&quot;</code>, <code>&quot;factors&quot;</code>,
<code>&quot;ordered&quot;</code>, and <code>&quot;missings&quot;</code>. Typically, only the
<code>&quot;missings&quot;</code> part is interesting since <code>CPO</code>s that
only handle a subset of types will usually just ignore columns of other
types.</p>
<p>The <strong><code>properties.target</code></strong> parameter defines
what <code>Task</code> properties related to the task type and the
target column a <code>CPO</code> can handle. It is a subset of
<code>&quot;cluster&quot;</code>, <code>&quot;classif&quot;</code>,
<code>&quot;multilabel&quot;</code>, <code>&quot;regr&quot;</code>, <code>&quot;surv&quot;</code> (so
far defining the task type a <code>CPO</code> can handle),
<code>&quot;oneclass&quot;</code>, <code>&quot;twoclass&quot;</code>,
<code>&quot;multiclass&quot;</code> (properties specific to <code>classif</code>
<code>Task</code>s). Most FOCPOs do not care about the task type, while
TOCPOs may only support a single task type.</p>
<p><strong><code>properties.adding</code></strong> lists the properties
that a CPO <em>adds</em> to the capabilities of a machine learning
pipeline when it is executed before it, while
<strong><code>properties.needed</code></strong> lists the properties
<em>needed</em> from the following pipeline.
<code>cpoDummyEncode</code>, for example, a <code>CPO</code> that
converts factors and ordereds to numerics, has
<code>properties.adding == c(&quot;factors&quot;, &quot;ordered&quot;)</code> and
<code>properties.needed == &quot;numerics&quot;</code>. The many imputation
<code>CPO</code>s have <code>properties.adding == &quot;missings&quot;</code>.
Usually these are only a subset of the possible
<code>properties.data</code> states, but for TOCPOs this may also be any
of <code>&quot;oneclass&quot;</code>, <code>&quot;twoclass&quot;</code>,
<code>&quot;multiclass&quot;</code>. Note that neither
<code>properties.adding</code> nor <code>properties.needed</code> may be
any task type, even for TOCPOs that perform task conversion.</p>
<div id="property-checking-and-.sometimes-properties" class="section level4">
<h4>Property Checking and <code>.sometimes</code> Properties</h4>
<p>The <code>CPO</code> framework will check that a <code>CPO</code>
only adds and removes the kind of data properties that it declared in
<code>properties.adding</code> and <code>properties.needed</code>. It
will also check that composition of <code>CPO</code>s, and attachment of
<code>CPO</code>s to <code>Learner</code>s, work out. Sometimes,
however, it is necessary to treat a <code>CPO</code> like it does a
certain manipulation (removing <code>missings</code>, for example) in
some cases, while not in others. A <code>CPO</code> that only imputes
missings in <em>numeric</em> columns should be treated as
<code>properties.adding == &quot;missings&quot;</code> when is is attached to a
<code>Learner</code>, and the <code>Learner</code> should gain the
<code>&quot;missings&quot;</code> property. However, when data that has missings
in its factorial columns is given to this <code>CPO</code>, the
<code>CPO</code> framework will complain that the <code>CPO</code> that
declared <code>&quot;missings&quot;</code> in <code>properties.adding</code>
returned data that still had missing values in it. The solution to this
dilemma is to suffix some properties with “<code>.sometimes</code>” when
declaring them in <code>properties.adding</code> and
<code>properties.needed</code>. When composing <code>CPO</code>s, and
when checking data <em>returned</em> by a <code>CPO</code>, the
framework will then be as lenient as possible. In the given example,
<code>properties.adding == &quot;missings&quot;</code> will be assumed when
attaching the <code>CPO</code> to a <code>Learner</code>, while
<code>properties.adding == character(0)</code> is assumed when checking
the <code>CPO</code>’s output (and missing values that were not imputed
are therefore forgiven).</p>
</div>
</div>
<div id="packages" class="section level3">
<h3>Packages</h3>
<p>The single <strong><code>packages</code></strong> parameter can be
set to a <code>character</code> vector listing packages necessary for a
<code>CPO</code> to work. This is mostly useful when a <code>CPO</code>
should be defined as part of a package or script to be distributed. The
listed package will <em>not</em> automatically be <em>attached</em>, it
will only be <em>loaded</em>. This means that a function exported by a
package still needs to be called using <code>::</code>. The benefit of
declaring it in <code>packages</code> is that it will be loaded upon
<em>construction</em> of a <code>CPO</code>, which means that a user
will get immediate feedback about whether the <code>CPO</code> can be
used or needs more packages to be installed.</p>
</div>
<div id="transformation-functions" class="section level3">
<h3>Transformation Functions</h3>
<p>The different types of <code>CPO</code>, and the different
<code>make*()</code> functions, need different transformation functions
to be defined. The principle behind these functions is alwasy the same,
however: The <code>CPO</code> framework takes input data, transforms it
according to <code>dataformat</code>, checks it according to
<code>properties.data</code> and <code>properties.target</code>, and
then gives it to one or more user-given transformation function. The
transformation function must then usually create a control object
containing information about the data to be used later, or transform the
incoming data and return the transformation result (or both). The
<code>CPO</code> framework then checks the transformed data according to
<code>properties.adding</code> and <code>properties.needed</code> and
gives it back to the <code>CPO</code> user.</p>
<p>Transformation functions are given to parameters starting with
<strong><code>cpo.</code></strong>. They can either be given as
functions, or as “<strong>headless</strong>” functions missing the
<code>function(...)</code> part. In the latter case, the headless
function must be a succession of expressions enclosed in curly braces
(<code>{</code>, <code>}</code>) and the necessary function head is
added by the <code>CPO</code> framework. The functions often take a
subset of <code>data</code>, <code>target</code>, <code>control</code>,
or <code>control.invert</code> parameters, in addition to all parameters
as given in <code>par.set</code>.</p>
<div id="functional-transformation" class="section level4">
<h4>Functional Transformation</h4>
<p>The communication between transformation functions, e.g. giving the
PCA matrix to its retrafo function, usually happens via “control”
objects created by these functions and then given as parameter to other
functions. In some cases, however, it may be more elegant to create a
new function (e.g. a <code>cpo.retrafo</code> function) within another
function as a “closure” (in the general, not R specific, sense) with
access to all the outer functions variables. The <code>CPO</code>
framework makes this possible by allowing a function to be given instead
of a “control” object. The function which would usually receive this
control object must then be given as <code>NULL</code> in the
<code>makeCPO*()</code> call.</p>
</div>
</div>
</div>
<div id="retrafoless-cpos" class="section level2">
<h2>Retrafoless CPOs</h2>
<p>Retrafoless <code>CPO</code>s, or ROCPOs, are conceptually the
simplest <code>CPO</code> type, since they do not create
<code>CPOTrained</code> objects and therefore only need one
transformation function: <code>cpo.trafo</code>. The value of the
<code>dataformat</code> parameter may only be either
<code>&quot;df.all&quot;</code> or <code>&quot;task&quot;</code>, resulting in either a
<code>data.frame</code> (consisting all columns, including the target
column) or a <code>Task</code> being given to the <code>cpo.trafo</code>
function. <code>cpo.trafo</code> should have the parameters
<code>data</code> (receiving the data as either a <code>Task</code> or
<code>data.frame</code>), <code>target</code> (receiving the names of
target columns in the data), and any parameter as given to
<code>par.set</code>. The return value of <code>cpo.trafo</code> must be
the transformed data, in the same format (<code>data.frame</code> or
<code>Task</code>) as given as input.</p>
<p>Since a ROCPO only transforms incoming data during training, it
should not do any transformation of target or feature values that would
make it necessary to repeat this action during prediction. It may, for
example, be used for subsampling a classification task to balance target
classes, but it should not change the levels or values of given data
rows.</p>
<p>The following is an example of a simplified version of the
<code>cpoSample</code> <code>CPO</code>, which takes one parameter
<code>fraction</code> and then subsamples a <code>fraction</code> part
of incoming data without replacement:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>xmpSample <span class="ot">=</span> <span class="fu">makeCPORetrafoless</span>(<span class="st">&quot;exsample&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pSS</span>(fraction<span class="sc">:</span> numeric[<span class="dv">0</span>, <span class="dv">1</span>]),</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">dataformat =</span> <span class="st">&quot;df.all&quot;</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.trafo =</span> <span class="cf">function</span>(data, target, fraction) {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    newsize <span class="ot">=</span> <span class="fu">round</span>(<span class="fu">nrow</span>(data) <span class="sc">*</span> fraction)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    row.indices <span class="ot">=</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(data), newsize)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    data[row.indices, ]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpSample</span>(<span class="fl">0.01</span>)</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>iris <span class="sc">%&gt;&gt;%</span> cpo</span></code></pre></div>
<p>It is possible to give the <code>cpo.trafo</code> as
<strong>headless</strong> transformation function by just leaving out
the function header. This can save a lot of boilerplate code when there
are many parameters present, or when many transformation functions need
to be given. The resulting <code>CPO</code> is completely equivalent to
the one given above.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>xmpSampleHeadless <span class="ot">=</span> <span class="fu">makeCPORetrafoless</span>(<span class="st">&quot;exsample&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pSS</span>(fraction<span class="sc">:</span> numeric[<span class="dv">0</span>, <span class="dv">1</span>]),</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">dataformat =</span> <span class="st">&quot;df.all&quot;</span>,</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.trafo =</span> {</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    newsize <span class="ot">=</span> <span class="fu">round</span>(<span class="fu">nrow</span>(data) <span class="sc">*</span> fraction)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    row.indices <span class="ot">=</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(data), newsize)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    data[row.indices, ]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  })</span></code></pre></div>
</div>
<div id="feature-operation-cpos" class="section level2">
<h2>Feature Operation CPOs</h2>
<p>FOCPOs are created with either the <code>makeCPO()</code> function,
or the <code>makeCPOExtendedTrafo()</code> function. The former
conceptually separates training from transformation, the latter
separates transformation of training data from transformation of
prediction data.</p>
<div id="makecpo" class="section level3">
<h3><code>makeCPO()</code></h3>
<p>In principle, a FOCPO needs a function that “trains” a control object
depending on the data (<code>cpo.train</code>), and another function
that uses this control object, and new data, to perform the
preprocessing operation (<code>cpo.retrafo</code>). The
<code>cpo.train</code>-function must return a “control” object which
contains all information about how to transform a given dataset.
<code>cpo.retrafo</code> takes a (potentially new!) dataset <em>and</em>
the “control” object returned by <code>cpo.trafo</code>, and transforms
the new data according to plan.</p>
<p>In contrast to <code>makeCPORetrafoless()</code>, the
<code>dataformat</code> parameter of <code>makeCPO()</code> can take all
values described in the section <a href="#data-format">Data Format</a>.
The <code>cpo.train</code> function takes the arguments
<code>data</code>, <code>target</code>, and any other parameter
described in <code>param.set</code>. The <code>data</code> value is the
incoming data as a <code>Task</code>, a <code>data.frame</code> with or
without the target column, or a list of <code>data.frames</code> of
different column types, according to <code>dataformat</code>. The
<code>target</code> value is a <code>character</code> vector of target
names if <code>dataformat</code> is <code>&quot;task&quot;</code> or
<code>&quot;df.all&quot;</code>, or a <code>data.frame</code> of the target
columns otherwise.</p>
<p>The <code>cpo.train</code> function’s return value is treated as a
<code>control</code> object and given to the <code>cpo.retrafo</code>
function. Its parameters are <code>data</code>, <code>control</code>,
and any parameters in <code>par.set</code>. The format of the data given
to the <code>data</code> parameter is according to
<code>dataformat</code>, with the exception that if
<code>dataformat</code> is either <code>&quot;task&quot;</code> or
<code>&quot;df.all&quot;</code>, it will be treated here as if its value were
<code>&quot;df.features&quot;</code>. This is because the <code>cpo.retrafo</code>
function is sometimes called with <em>prediction</em> data which does
not have any target column at all.</p>
<p>It follows the simplified definition of a <code>CPO</code> that
removes the numeric columns of smallest variance, returning a dataset of
only <code>n.col</code> numeric columns. The <code>dataformat</code>
variable is set to <code>&quot;numeric&quot;</code>, so that only numeric columns
are given to the <code>CPO</code>’s transformation functiosn; factorial
columns are ignored. In <code>cpo.trafo</code>, calculates the variance
of each of the data’s columns, and in <code>cpo.retrafo</code> it
subsets the data according to these variances. Since
<code>cpo.retrafo</code> may also be called during prediction with new
data, the variance must <em>not</em> be calculated in
<code>cpo.retrafo</code>–this could lead to <code>cpo.retrafo</code>
filtering out different columns from <code>cpo.trafo</code>. This
example also prints out which of its functions are being called.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>xmpFilterVar <span class="ot">=</span> <span class="fu">makeCPO</span>(<span class="st">&quot;exemplvar&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pSS</span>(n.col<span class="sc">:</span> integer[<span class="dv">0</span>, ]),</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">dataformat =</span> <span class="st">&quot;numeric&quot;</span>,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.train =</span> <span class="cf">function</span>(data, target, n.col) {</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.train ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sapply</span>(data, var, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cf">function</span>(data, control, n.col) {</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;Control:</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(control)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    greatest <span class="ot">=</span> <span class="fu">order</span>(<span class="sc">-</span>control)  <span class="co"># columns, ordered greatest to smallest var</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    data[greatest[<span class="fu">seq_len</span>(n.col)]]</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpFilterVar</span>(<span class="dv">2</span>)</span></code></pre></div>
<p>(Note that the function heads are optional.)</p>
<p>When the <code>CPO</code> is called with a dataset, the
<code>cpo.train</code> function is called first, creating the control
object which is then given to <code>cpo.retrafo</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="at">trafd =</span> <span class="fu">head</span>(iris) <span class="sc">%&gt;&gt;%</span> cpo)</span></code></pre></div>
<p>Note that the two columns of the entire <code>iris</code> dataset
with the greatest variance are <code>Petal.Length</code> and
<code>Sepal.Length</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(iris <span class="sc">%&gt;&gt;%</span> cpo)</span></code></pre></div>
<p>However, when applying the <code>retrafo()</code> of
<code>trafd</code> to the entire dataset, the same columns are filtered
out as they were in the first transformation: <code>Sepal.Width</code>
and <code>Sepal.Length</code>. When the <code>retrafo()</code> is used,
<code>cpo.train</code> is <em>not</em> called; instead, the
<code>control</code> object saved inside the retrafo is used.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(iris <span class="sc">%&gt;&gt;%</span> <span class="fu">retrafo</span>(trafd))</span></code></pre></div>
<p>It is also possible to inspect the <code>CPOTrained</code> object to
see that the <code>control</code> is there:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getCPOTrainedState</span>(<span class="fu">retrafo</span>(trafd))</span></code></pre></div>
<div id="functional-focpo" class="section level4">
<h4>Functional FOCPO</h4>
<p>Instead of returning the <code>control</code> object,
<code>cpo.train</code> may also return the <code>cpo.retrafo</code>
<em>function</em>. This may be more succinct to write if there are many
little pieces of information from the <code>cpo.train</code> run that
the <code>cpo.retrafo</code> function should have access to.</p>
<p>When <code>cpo.retrafo</code> is given functionally, it should be a
function with only <em>one</em> parameter: the newly incoming data. It
can access the values of the <code>par.set</code> parameters from its
encapsulating environment in <code>cpo.train</code>.</p>
<p>Note that the <code>data</code> and <code>target</code> values given
to <code>cpo.train</code> are <strong>deleted</strong> after the
<code>cpo.train</code> call, so <code>cpo.retrafo</code> does not have
access to it. In fact, the <code>CPO</code> framework will give a
warning about this.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>xmpFilterVarFunc <span class="ot">=</span> <span class="fu">makeCPO</span>(<span class="st">&quot;exemplvar.func&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pSS</span>(n.col<span class="sc">:</span> integer[<span class="dv">0</span>, ]),</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">dataformat =</span> <span class="st">&quot;numeric&quot;</span>,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cn">NULL</span>,</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.train =</span> <span class="cf">function</span>(data, target, n.col) {</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.train ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    ctrl <span class="ot">=</span> <span class="fu">sapply</span>(data, var, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">function</span>(x) {  <span class="co"># the data is given to the only present parameter: &#39;x&#39;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">&quot;Control:</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span>(ctrl)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">data:</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span>(data)  <span class="co"># &#39;data&#39; is deleted: NULL</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">&quot;target:</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span>(target)  <span class="co"># &#39;target&#39; is deleted: NULL</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>      greatest <span class="ot">=</span> <span class="fu">order</span>(<span class="sc">-</span>ctrl)  <span class="co"># columns, ordered greatest to smallest var</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>      x[greatest[<span class="fu">seq_len</span>(n.col)]]</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpFilterVarFunc</span>(<span class="dv">2</span>)</span></code></pre></div>
<p>(Note that the function heads are optional.)</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(<span class="at">trafd =</span> <span class="fu">head</span>(iris) <span class="sc">%&gt;&gt;%</span> cpo)</span></code></pre></div>
<p>The <code>CPOTrained</code> state for a functional <code>CPO</code>
is the <em>environment</em> of the retrafo function. It contains the
“<code>ctrl</code>” variable defined during training, the parameters
given to <code>cpo.train</code>, and the <code>cpo.retrafo</code>
function itself. Note that <code>data</code> and <code>target</code> are
deleted and replaced by different values.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getCPOTrainedState</span>(<span class="fu">retrafo</span>(trafd))</span></code></pre></div>
</div>
<div id="stateless-focpo" class="section level4">
<h4>Stateless FOCPO</h4>
<p>“Stateless” <code>CPO</code>s are <code>CPO</code>s that perform the
same action during transformation of training and prediction data,
independent from information during training. An example would be a
<code>CPO</code> that converts all its columns to <code>numeric</code>
columns. When a FOCPO does not need a state, the <code>cpo.train</code>
parameter of <code>makeCPO()</code> can be set to <code>NULL</code>. The
<code>cpo.retrafo</code> function then has no <code>control</code>
paramter and instead only a <code>data</code> and any
<code>par.set</code> parameter. The
<code>as.numeric</code>-<code>CPO</code> could be written as the
following:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>xmpAsNum <span class="ot">=</span> <span class="fu">makeCPO</span>(<span class="st">&quot;asnum&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.train =</span> <span class="cn">NULL</span>,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cf">function</span>(data) {</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">data.frame</span>(<span class="fu">lapply</span>(data, as.numeric))</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpAsNum</span>()</span></code></pre></div>
<p>(Note that the function head is optional.)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>(<span class="at">trafd =</span> <span class="fu">head</span>(iris) <span class="sc">%&gt;&gt;%</span> cpo)</span></code></pre></div>
<p>The “state” of the <code>CPOTrained</code> object thus created only
contains information about the incoming <em>data shape</em>, to make
sure that the <code>CPOTrained</code> object is only used on conforming
data (as doing otherwise would indicate a bug).</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getCPOTrainedState</span>(<span class="fu">retrafo</span>(trafd))</span></code></pre></div>
</div>
</div>
<div id="makecpoextendedtrafo" class="section level3">
<h3><code>makeCPOExtendedTrafo()</code></h3>
<p>Sometimes it is advantageous to have the training operation return
the transformed data right away. PCA, for example, returns the rotation
matrix <em>and</em> the transformed data; it would be a waste of time to
only return the rotation matrix in a <code>cpo.train</code> function and
apply it on the training data in <code>cpo.retrafo</code>. The
<code>makeCPOExtendedTrafo()</code> function works very much like
<code>makeCPO()</code>, with the difference that it has a
<code>cpo.trafo</code> instead of a <code>cpo.train</code> function
parameter. The <code>cpo.trafo</code> takes the same parameters as
<code>cpo.train</code>, but returns the <em>transformed data</em>
instead of a control object. The control object needs to be created
<em>additionally</em>, as a variable by the <code>cpo.trafo</code>
function. The <code>CPO</code> framework takes the value of a variable
named <code>control</code> inside the <code>cpo.trafo</code> function
and gives it to the <code>cpo.retrafo</code> function.</p>
<p>The following is a simplified version of the <code>cpoPca</code>
<code>CPO</code>, which does not scale or center the data.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>xmpPca <span class="ot">=</span> <span class="fu">makeCPOExtendedTrafo</span>(<span class="st">&quot;simple.pca&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pSS</span>(n.col<span class="sc">:</span> integer[<span class="dv">0</span>, ]),</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">dataformat =</span> <span class="st">&quot;numeric&quot;</span>,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.trafo =</span> <span class="cf">function</span>(data, target, n.col) {</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.trafo ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    pcr <span class="ot">=</span> <span class="fu">prcomp</span>(<span class="fu">as.matrix</span>(data), <span class="at">center =</span> <span class="cn">FALSE</span>, <span class="at">scale. =</span> <span class="cn">FALSE</span>, <span class="at">rank =</span> n.col)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># save the rotation matrix as &#39;control&#39; variable</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    control <span class="ot">=</span> pcr<span class="sc">$</span>rotation</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    pcr<span class="sc">$</span>x</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cf">function</span>(data, control, n.col) {</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># rotate the data by the rotation matrix</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.matrix</span>(data) <span class="sc">%*%</span> control</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpPca</span>(<span class="dv">2</span>)</span></code></pre></div>
<p>When this <code>CPO</code> is applied to data, only the
<code>cpo.trafo</code> function is called.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>(<span class="at">trafd =</span> <span class="fu">head</span>(iris) <span class="sc">%&gt;&gt;%</span> cpo)</span></code></pre></div>
<p>When the retrafo <code>CPOTrained</code> is used, the
<code>cpo.retrafo</code> function is called, making use of the rotation
matrix.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(iris) <span class="sc">%&gt;&gt;%</span> <span class="fu">retrafo</span>(trafd)</span></code></pre></div>
<p>The rotation matrix can be inspected using
<code>getCPOTrainedState</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getCPOTrainedState</span>(<span class="fu">retrafo</span>(trafd))</span></code></pre></div>
<div id="functional-focpo-1" class="section level4">
<h4>Functional FOCPO</h4>
<p>As with <code>makeCPO()</code>, <code>makeCPOExtendedTrafo()</code>
makes it possible to define functional <code>CPO</code>s. Instead of
<em>returning</em> a <code>cpo.retrafo</code> function, the
<code>cpo.retrafo</code> function needs to be <em>defined</em> as a
variable, instead of a “<code>control</code>” variable. Like in
<code>makeCPO()</code>, the <code>cpo.retrafo</code> parameter of
<code>makeCPOExtendedTrafo()</code> must then be <code>NULL</code>. The
PCA example above could thus also be written as</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>xmpPcaFunc <span class="ot">=</span> <span class="fu">makeCPOExtendedTrafo</span>(<span class="st">&quot;simple.pca.func&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pSS</span>(n.col<span class="sc">:</span> integer[<span class="dv">0</span>, ]),</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">dataformat =</span> <span class="st">&quot;numeric&quot;</span>,</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cn">NULL</span>,</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.trafo =</span> <span class="cf">function</span>(data, target, n.col) {</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.trafo ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    pcr <span class="ot">=</span> <span class="fu">prcomp</span>(<span class="fu">as.matrix</span>(data), <span class="at">center =</span> <span class="cn">FALSE</span>, <span class="at">scale. =</span> <span class="cn">FALSE</span>, <span class="at">rank =</span> n.col)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># save the rotation matrix as &#39;control&#39; variable</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    cpo.retrafo <span class="ot">=</span> <span class="cf">function</span>(data) {</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>      <span class="co"># rotate the data by the rotation matrix</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">as.matrix</span>(data) <span class="sc">%*%</span> pcr<span class="sc">$</span>rotation</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    pcr<span class="sc">$</span>x</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpPcaFunc</span>(<span class="dv">2</span>)</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>(<span class="at">trafd =</span> <span class="fu">head</span>(iris) <span class="sc">%&gt;&gt;%</span> cpo)</span></code></pre></div>
<p>This also serves as an example of the disadvantages of a functional
<code>CPO</code>: Since the <code>CPO</code> state contains all the
information contained in the <code>cpo.trafo</code> call (except the
<code>data</code> and <code>target</code> variables), it may take up
more memory than needed. For this <code>CPO</code>, the state contains
the <code>pcr</code> variable which contains the transformed training
data in its <code>$x</code> slot. If the training data is a very large
dataset, this would result in <code>CPO</code> states that take up a lot
of working memory.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getCPOTrainedState</span>(<span class="fu">retrafo</span>(trafd))<span class="sc">$</span>pcr<span class="sc">$</span>x</span></code></pre></div>
</div>
</div>
</div>
<div id="target-operation-cpos" class="section level2">
<h2>Target Operation CPOs</h2>
<p>TOCPOs are more complicated than FOCPOs, since they potentially need
to operate on data at three different points: During initial training,
during the re-transformation for new prediction data, and during the
inversion of predictions made by a model trained on transformed data.
Similarly to <code>makeCPO()</code>, <code>makeCPOTargetOp()</code>
splits these operations up into functions that create
“<code>control</code>” objects, and functions that do the actual
transformation. <code>makeCPOExtendedTargetOp()</code>, on the other
hand, gives the user more flexibility at the price of the user having to
make sure that transformation and retransformation perform the same
operation–similarly to <code>makeCPOExtendedTrafo()</code> for
FOCPOs.</p>
<div id="task-type-and-conversion" class="section level3">
<h3>Task Type and Conversion</h3>
<p>In contrast to FOCPOs, TOCPOs can only operate on one type of
<code>Task</code>. Therefore, the <code>properties.target</code>
parameter of <code>makeCPO*TargetOp()</code> must contain exactly one
<code>Task</code> type (<code>&quot;cluster&quot;</code>, <code>&quot;classif&quot;</code>,
<code>&quot;regr&quot;</code>, <code>&quot;surv&quot;</code>, <code>&quot;multilabel&quot;</code>) and
possibly some more task properties (currently only
<code>&quot;oneclass&quot;</code>, <code>&quot;twoclass&quot;</code>,
<code>&quot;multiclass&quot;</code> if the <code>Task</code> type is
<code>&quot;classif&quot;</code>).</p>
<p>It is possible to write TOCPOs that perform <em>conversion</em> of
<code>Task</code> types. For that, the <code>task.type.out</code>
parameter must be set to the <code>Task</code> type that the
<code>CPO</code> converts the data to. If conversion happens, the
transformation functions need to return target data fit for the
<code>task.type.out</code> <code>Task</code> type.</p>
<p><code>properties.adding</code> and <code>properties.needed</code>
should <em>not</em> be any <code>Task</code> type, even when conversion
happens. Only if one of the task types has <em>additional</em>
properties–currently only the <code>&quot;oneclass&quot;</code>,
<code>&quot;twoclass&quot;</code>, <code>&quot;multiclass&quot;</code> properties of
classification <code>Task</code>s–should these additional properties be
listed in <code>properties.adding</code> or
<code>properties.needed</code>.</p>
</div>
<div id="predict.type" class="section level3">
<h3><code>predict.type</code></h3>
<p><code>mlr</code> makes it possible for <code>Learner</code>s to make
different kinds of prediction. Usually they can predict a “response”,
making their best effort to predict the true value of a task target.
Many <code>Learner</code> types can predict a probability when their
<code>predict.type</code> is set to <code>&quot;prob&quot;</code>, returning a
<code>data.frame</code> of their estimated probability distribution over
possible responses. For regression <code>Learner</code>s,
<code>predict.type</code> can be <code>&quot;se&quot;</code> for the
<code>Learner</code> to predict its estimated standard error of their
response prediction.</p>
<p>When TOCPOs invert these predictions, they may</p>
<ul>
<li>declare which kind of <code>predict.type</code> predictions they can
perform</li>
<li>declare what <code>predict.type</code> they require from the
underlying <code>Learner</code> to make this <code>predict.type</code>
prediction.</li>
</ul>
<p>This is done using the <code>predict.type.map</code> parameter of
<code>makeCPO*TargetOp()</code>. It is a named <code>list</code> or
named <code>character</code> vector with the names indicating the
supported <code>predict.type</code>s, and the values indicating the
required underlying predictions. For example, if a TOCPO can perform
<code>&quot;response&quot;</code> and <code>&quot;se&quot;</code> prediction, and to predict
<code>&quot;response&quot;</code> the underlying <code>Learner</code> must also
perform <code>&quot;response&quot;</code> prediction, but for <code>&quot;se&quot;</code>
prediction it must perform <code>&quot;prob&quot;</code> prediction, the
<code>predict.type.map</code> would have the value</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="at">response =</span> <span class="st">&quot;response&quot;</span>, <span class="at">se =</span> <span class="st">&quot;prob&quot;</span>)</span></code></pre></div>
</div>
<div id="makecpotargetop" class="section level3">
<h3><code>makeCPOTargetOp()</code></h3>
<p><code>makeCPOTargetOp()</code> has a <code>cpo.train</code> and
<code>cpo.retrafo</code> function parameter that work similarly to the
ones of <code>makeCPO()</code>. In contrast to <code>makeCPO()</code>,
however, <code>cpo.retrafo</code> must return the <em>target</em> data
instead of the feature data. The <code>data</code> and
<code>target</code> parameters of <code>cpo.retrafo</code> get the same
data as they get in a FOCPO created with <code>makeCPO()</code>, with
the exception that if <code>dataformat</code> is <code>&quot;task&quot;</code> or
<code>&quot;df.all&quot;</code>, the <code>target</code> parameter will receive
the <em>whole</em> input data in form of a <code>Task</code> or
<code>data.frame</code> (while the <code>data</code> argument, as in a
FOCPO, will receive only the feature <code>data.frame</code>). The
return value of <code>cpo.retrafo</code> for a TOCPO must always be in
the same format as the input <code>target</code> value: a
<code>data.frame</code> with the manipulated target values when
<code>dataformat</code> is anything besides <code>&quot;task&quot;</code> or
<code>&quot;df.all&quot;</code>, or a <code>Task</code> or <code>data.frame</code>
of all data (with non-target columns unmodified) otherwise.</p>
<p>Inversion of predictions is performed using the functions
<code>cpo.train.invert</code> and <code>cpo.invert</code>.
<code>cpo.train.invert</code> takes a <code>data</code> and a
<code>control</code> argument, and any arguments declared in the
<code>par.set</code>. It is called whenever new data is fed into the
<code>CPO</code> or its retrafo <code>CPOTrained</code>, and creates a
<code>CPOTrained</code> state that is used to invert the prediction done
on this new data. The <code>control</code> argument takes the value
returned by the <code>cpo.train</code> function upon initial training,
and the <code>data</code> argument is the new data for which to prepare
the <code>CPOTrained</code> inverter. It has the form dictated by
<code>dataformat</code>, with the exception that <code>&quot;task&quot;</code> and
<code>&quot;df.all&quot;</code> <code>dataformat</code> are handled as
<code>&quot;df.feature&quot;</code>; this is necessary since the new data could be
a <code>data.frame</code> of data with unknown target.</p>
<p>The following is an example of a TOCPO that trains a classification
<code>Learner</code> on a binary classification <code>Task</code> and
changes it to a <code>Task</code> of whether or not the
<code>Learner</code> predicted the truth for a given data line
correctly. (Real-world applications would probably need to take some
precautions against overfitting.) In its <code>cpo.train</code> step,
the given <code>Learner</code> is trained on the incoming data and the
resulting <code>WrappedModel</code> object is returned as the
“<code>control</code>” object. This is given to the
<code>cpo.retrafo</code> function, which performs prediction and creates
a new classification <code>Task</code> with the match / mismatch between
model prediction and ground truth as target. When an external
<code>Learner</code> is trained on data that was preprocessed like this,
its prediction will be whether the <code>CPO</code>-internal
<code>Learner</code> can be trusted to predict a given data row. To
“invert” this, i.e. to get the actual prediction, the
<code>cpo.invert</code> function needs to have the internal
<code>Learner</code>’s prediction as well as the prediction made by the
external <code>Learner</code>. The former is provided by
<code>cpo.train.invert</code>, which uses the <code>WrappedModel</code>
to make a prediction on the new data, and given as
<code>control.invert</code> to <code>cpo.invert</code>. The latter is
the <code>target</code> data given to <code>cpo.invert</code>. This
example <code>CPO</code> supports inverting both <code>&quot;response&quot;</code>
and <code>&quot;prob&quot;</code> <code>predict.type</code> predictions, as
declared in the <code>predict.type.map</code> argument. The actual
<code>predict.type</code> to invert is given to <code>cpo.invert</code>
as an argument.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>xmpMetaLearn <span class="ot">=</span> <span class="fu">makeCPOTargetOp</span>(<span class="st">&quot;xmp.meta&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pSS</span>(lrn<span class="sc">:</span> untyped),</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">dataformat =</span> <span class="st">&quot;task&quot;</span>,</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">properties.target =</span> <span class="fu">c</span>(<span class="st">&quot;classif&quot;</span>, <span class="st">&quot;twoclass&quot;</span>),</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">predict.type.map =</span> <span class="fu">c</span>(<span class="at">response =</span> <span class="st">&quot;response&quot;</span>, <span class="at">prob =</span> <span class="st">&quot;prob&quot;</span>),</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.train =</span> <span class="cf">function</span>(data, target, lrn) {</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.train ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    lrn <span class="ot">=</span> <span class="fu">setPredictType</span>(lrn, <span class="st">&quot;prob&quot;</span>)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">train</span>(lrn, data)</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cf">function</span>(data, target, control, lrn) {</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    prediction <span class="ot">=</span> <span class="fu">predict</span>(control, target)</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    tname <span class="ot">=</span> <span class="fu">getTaskTargetNames</span>(target)</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    tdata <span class="ot">=</span> <span class="fu">getTaskData</span>(target)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    tdata[[tname]] <span class="ot">=</span> <span class="fu">factor</span>(prediction<span class="sc">$</span>data<span class="sc">$</span>response <span class="sc">==</span> prediction<span class="sc">$</span>data<span class="sc">$</span>truth)</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">makeClassifTask</span>(<span class="fu">getTaskId</span>(target), tdata, tname, <span class="at">positive =</span> <span class="st">&quot;TRUE&quot;</span>,</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>      <span class="at">fixup.data =</span> <span class="st">&quot;no&quot;</span>, <span class="at">check.data =</span> <span class="cn">FALSE</span>)</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.train.invert =</span> <span class="cf">function</span>(data, control, lrn) {</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.train.invert ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predict</span>(control, <span class="at">newdata =</span> data)<span class="sc">$</span>data</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.invert =</span> <span class="cf">function</span>(target, control.invert, predict.type, lrn) {</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.invert ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (predict.type <span class="sc">==</span> <span class="st">&quot;prob&quot;</span>) {</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>      outmat <span class="ot">=</span> <span class="fu">as.matrix</span>(control.invert[<span class="fu">grep</span>(<span class="st">&quot;^prob</span><span class="sc">\\</span><span class="st">.&quot;</span>, <span class="fu">names</span>(control.invert))])</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>      revmat <span class="ot">=</span> outmat[, <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">1</span>)]</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>      outmat <span class="sc">*</span> target[, <span class="st">&quot;prob.TRUE&quot;</span>, drop <span class="ot">=</span> <span class="cn">TRUE</span>] <span class="sc">+</span></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>        revmat <span class="sc">*</span> target[, <span class="st">&quot;prob.FALSE&quot;</span>, drop <span class="ot">=</span> <span class="cn">TRUE</span>]</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>      <span class="fu">stopifnot</span>(<span class="fu">levels</span>(target) <span class="sc">==</span> <span class="fu">c</span>(<span class="st">&quot;FALSE&quot;</span>, <span class="st">&quot;TRUE&quot;</span>))</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>      numeric.prediction <span class="ot">=</span> <span class="fu">as.numeric</span>(control.invert<span class="sc">$</span>response)</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>      numeric.res <span class="ot">=</span> <span class="fu">ifelse</span>(target <span class="sc">==</span> <span class="st">&quot;TRUE&quot;</span>,</span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>        numeric.prediction,</span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>        <span class="dv">3</span> <span class="sc">-</span> numeric.prediction)</span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>      <span class="fu">factor</span>(<span class="fu">levels</span>(control.invert<span class="sc">$</span>response)[numeric.res],</span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a>        <span class="fu">levels</span>(control.invert<span class="sc">$</span>response))</span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpMetaLearn</span>(<span class="fu">makeLearner</span>(<span class="st">&quot;classif.logreg&quot;</span>))</span></code></pre></div>
<p>To show the inner workings of this <code>CPO</code>, the following
example data is used.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>split <span class="ot">=</span> <span class="fu">makeResampleInstance</span>(hout, pid.task)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>train.task <span class="ot">=</span> <span class="fu">subsetTask</span>(pid.task, split<span class="sc">$</span>train.inds[[<span class="dv">1</span>]])</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>test.task <span class="ot">=</span> <span class="fu">subsetTask</span>(pid.task, split<span class="sc">$</span>predict.inds[[<span class="dv">1</span>]])</span></code></pre></div>
<p>It can be instructive to watch the <code>cat()</code> output of this
<code>CPO</code> to see which function gets called at what point in the
lifecycle. The <code>cpo.train</code> function is called first to create
the <code>control</code> object. The <code>Task</code> is transformed in
<code>cpo.retrafo</code>. Also <code>cpo.train.invert</code> is called,
since an <code>inverter</code> attribute is attached to the returned
trafo.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>trafd <span class="ot">=</span> train.task <span class="sc">%&gt;&gt;%</span> cpo</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">attributes</span>(trafd)</span></code></pre></div>
<p>The values of the target column (“diabetes”) of the result can be
compared with the prediction of a <code>&quot;classif.logreg&quot;</code>
<code>Learner</code> on the same data:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">getTaskData</span>(trafd))</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">=</span> <span class="fu">train</span>(<span class="fu">makeLearner</span>(<span class="st">&quot;classif.logreg&quot;</span>, <span class="at">predict.type =</span> <span class="st">&quot;prob&quot;</span>), train.task)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">predict</span>(model, train.task)<span class="sc">$</span>data[<span class="fu">c</span>(<span class="st">&quot;truth&quot;</span>, <span class="st">&quot;response&quot;</span>)])</span></code></pre></div>
<p>When new data is transformed using the retrafo
<code>CPOTrained</code>, another <code>inverter</code> attribute is
created, and hence <code>cpo.train.invert</code> is called again. Since
the target column of the <code>test.task</code> in the following example
is also transformed, the <code>cpo.retrafo</code> function is
called.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>retr <span class="ot">=</span> test.task <span class="sc">%&gt;&gt;%</span> <span class="fu">retrafo</span>(trafd)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">attributes</span>(retr)</span></code></pre></div>
<p>In a real world application, it would be possible for the new
incoming data to have unknown target values. In that case, no target
column would need to be changed, and <code>cpo.retrafo</code> is
<em>not</em> called. The resulting data, <code>retr.df</code>, equals
the input data with a <code>retrafo</code> attribute added.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>retr.df <span class="ot">=</span> <span class="fu">getTaskData</span>(test.task, <span class="at">target.extra =</span> <span class="cn">TRUE</span>)<span class="sc">$</span>data <span class="sc">%&gt;&gt;%</span> <span class="fu">retrafo</span>(trafd)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(<span class="fu">attributes</span>(retr.df))</span></code></pre></div>
<p>The invert functionality can be demonstrated by making a prediction
with an external model.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>ext.model <span class="ot">=</span> <span class="fu">train</span>(<span class="st">&quot;classif.svm&quot;</span>, trafd)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>ext.pred <span class="ot">=</span> <span class="fu">predict</span>(ext.model, retr)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>newpred <span class="ot">=</span> <span class="fu">invert</span>(<span class="fu">inverter</span>(retr), ext.pred)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="fu">performance</span>(newpred)</span></code></pre></div>
<p>It may also be instructive to attach the <code>xmpMetaLearn</code>
<code>CPO</code> to a <code>Learner</code> to see which functions get
called during training and prediction of a TOCPO-<code>Learner</code>.
Since the <code>Learner</code> does not do inversion of the training
data, a <code>CPOTrained</code> for inversion is not created during
training, and <code>cpo.train.invert</code> is hence not called. Only
<code>cpo.train</code> (for control object creation) and
<code>cpo.retrafo</code> (target value change) are called. During
prediction, the input data is used to create an (internally used)
inversion <code>CPOTrained</code> which promptly gets used by the
prediction made by <code>&quot;classif.svm&quot;</code>. Hence both
<code>cpo.train.invert</code> and <code>cpo.invert</code> are called in
succession.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>cpo.learner <span class="ot">=</span> cpo <span class="sc">%&gt;&gt;%</span> <span class="fu">makeLearner</span>(<span class="st">&quot;classif.svm&quot;</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>cpo.model <span class="ot">=</span> <span class="fu">train</span>(cpo.learner, train.task)</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>lrnpred <span class="ot">=</span> <span class="fu">predict</span>(cpo.model, test.task)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">performance</span>(lrnpred)</span></code></pre></div>
<p>See <a href="#postscriptum">Postscriptum</a> for an evaluation of
<code>xmpMeatLearn</code>’s performance.</p>
<div id="functional-tocpo" class="section level4">
<h4>Functional TOCPO</h4>
<p>Just like for FOCPOs, it is possible to create functional TOCPOs. In
the case of <code>makeCPOTargetOp()</code>, it is possible to have
<code>cpo.train</code> create <code>cpo.retrafo</code> and
<code>cpo.train.invert</code>, instead of giving them to
<code>makeCPOTargetOp()</code> directly. Just as in
<code>makeCPO</code>, these functions can then access the state of their
environment in the <code>cpo.train</code> call and hence have neither a
<code>control</code> argument, nor any arguments for the
<code>par.set</code> parameters. Since <code>cpo.train</code> must in
this case create two functions, these functions only need to be defined
within <code>cpo.train</code>, the return value is ignored.</p>
<p>Note that <code>cpo.retrafo</code> and <code>cpo.train.invert</code>
must either be both functional or both object based.</p>
<p>It is furthermore possible to return a <code>cpo.invert</code>
function by <code>cpo.train.invert</code>, instead of giving it to
<code>makeCPOTargetOp()</code>. As above, the returned function should
not have any parameters for the ones given in <code>par.set</code>, and
should not have a <code>control.invert</code>. <code>cpo.invert</code>
can be functional or not, <em>independently</em> of whether
<code>cpo.retrafo</code> and <code>cpo.train.invert</code> are
functional.</p>
<p>As in <code>makeCPO()</code>, all functions that are given
functionally must be explicitly set to <code>NULL</code> in the
<code>makeCPOTargetOp()</code> call.</p>
<p>The <code>xmpMetaLearn</code> example above with functional
<code>cpo.retrafo</code>, <code>cpo.train.invert</code> and
<code>cpo.invert</code> would look like the following:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>xmpMetaLearn <span class="ot">=</span> <span class="fu">makeCPOTargetOp</span>(<span class="st">&quot;xmp.meta.fnc&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pSS</span>(lrn<span class="sc">:</span> untyped),</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">dataformat =</span> <span class="st">&quot;task&quot;</span>,</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">properties.target =</span> <span class="fu">c</span>(<span class="st">&quot;classif&quot;</span>, <span class="st">&quot;twoclass&quot;</span>),</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">predict.type.map =</span> <span class="fu">c</span>(<span class="at">response =</span> <span class="st">&quot;response&quot;</span>, <span class="at">prob =</span> <span class="st">&quot;prob&quot;</span>),</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># set the cpo.* parameters not needed to NULL:</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cn">NULL</span>, <span class="at">cpo.train.invert =</span> <span class="cn">NULL</span>, <span class="at">cpo.invert =</span> <span class="cn">NULL</span>,</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.train =</span> <span class="cf">function</span>(data, target, lrn) {</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.train ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    lrn <span class="ot">=</span> <span class="fu">setPredictType</span>(lrn, <span class="st">&quot;prob&quot;</span>)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>    model <span class="ot">=</span> <span class="fu">train</span>(lrn, data)</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>    cpo.retrafo <span class="ot">=</span> <span class="cf">function</span>(data, target) {</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>      prediction <span class="ot">=</span> <span class="fu">predict</span>(model, target)</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>      tname <span class="ot">=</span> <span class="fu">getTaskTargetNames</span>(target)</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>      tdata <span class="ot">=</span> <span class="fu">getTaskData</span>(target)</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>      tdata[[tname]] <span class="ot">=</span> <span class="fu">factor</span>(prediction<span class="sc">$</span>data<span class="sc">$</span>response <span class="sc">==</span> prediction<span class="sc">$</span>data<span class="sc">$</span>truth)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>      <span class="fu">makeClassifTask</span>(<span class="fu">getTaskId</span>(target), tdata, tname, <span class="at">positive =</span> <span class="st">&quot;TRUE&quot;</span>,</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a>        <span class="at">fixup.data =</span> <span class="st">&quot;no&quot;</span>, <span class="at">check.data =</span> <span class="cn">FALSE</span>)</span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a>    cpo.train.invert <span class="ot">=</span> <span class="cf">function</span>(data) {</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">&quot;*** cpo.train.invert ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true" tabindex="-1"></a>      prediction <span class="ot">=</span> <span class="fu">predict</span>(model, <span class="at">newdata =</span> data)<span class="sc">$</span>data</span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">function</span>(target, predict.type) {  <span class="co"># this is returned as cpo.invert</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true" tabindex="-1"></a>        <span class="fu">cat</span>(<span class="st">&quot;*** cpo.invert ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (predict.type <span class="sc">==</span> <span class="st">&quot;prob&quot;</span>) {</span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true" tabindex="-1"></a>          outmat <span class="ot">=</span> <span class="fu">as.matrix</span>(prediction[<span class="fu">grep</span>(<span class="st">&quot;^prob</span><span class="sc">\\</span><span class="st">.&quot;</span>, <span class="fu">names</span>(prediction))])</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true" tabindex="-1"></a>          revmat <span class="ot">=</span> outmat[, <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">1</span>)]</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true" tabindex="-1"></a>          outmat <span class="sc">*</span> target[, <span class="st">&quot;prob.TRUE&quot;</span>, drop <span class="ot">=</span> <span class="cn">TRUE</span>] <span class="sc">+</span></span>
<span id="cb34-31"><a href="#cb34-31" aria-hidden="true" tabindex="-1"></a>            revmat <span class="sc">*</span> target[, <span class="st">&quot;prob.FALSE&quot;</span>, drop <span class="ot">=</span> <span class="cn">TRUE</span>]</span>
<span id="cb34-32"><a href="#cb34-32" aria-hidden="true" tabindex="-1"></a>        } <span class="cf">else</span> {</span>
<span id="cb34-33"><a href="#cb34-33" aria-hidden="true" tabindex="-1"></a>          <span class="fu">stopifnot</span>(<span class="fu">levels</span>(target) <span class="sc">==</span> <span class="fu">c</span>(<span class="st">&quot;FALSE&quot;</span>, <span class="st">&quot;TRUE&quot;</span>))</span>
<span id="cb34-34"><a href="#cb34-34" aria-hidden="true" tabindex="-1"></a>          numeric.prediction <span class="ot">=</span> <span class="fu">as.numeric</span>(prediction<span class="sc">$</span>response)</span>
<span id="cb34-35"><a href="#cb34-35" aria-hidden="true" tabindex="-1"></a>          numeric.res <span class="ot">=</span> <span class="fu">ifelse</span>(target <span class="sc">==</span> <span class="st">&quot;TRUE&quot;</span>,</span>
<span id="cb34-36"><a href="#cb34-36" aria-hidden="true" tabindex="-1"></a>            numeric.prediction,</span>
<span id="cb34-37"><a href="#cb34-37" aria-hidden="true" tabindex="-1"></a>            <span class="dv">3</span> <span class="sc">-</span> numeric.prediction)</span>
<span id="cb34-38"><a href="#cb34-38" aria-hidden="true" tabindex="-1"></a>          <span class="fu">factor</span>(<span class="fu">levels</span>(prediction<span class="sc">$</span>response)[numeric.res],</span>
<span id="cb34-39"><a href="#cb34-39" aria-hidden="true" tabindex="-1"></a>            <span class="fu">levels</span>(prediction<span class="sc">$</span>response))</span>
<span id="cb34-40"><a href="#cb34-40" aria-hidden="true" tabindex="-1"></a>        }        </span>
<span id="cb34-41"><a href="#cb34-41" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb34-42"><a href="#cb34-42" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb34-43"><a href="#cb34-43" aria-hidden="true" tabindex="-1"></a>  })</span></code></pre></div>
</div>
<div id="constant-invert-tocpos" class="section level4">
<h4>Constant Invert TOCPOs</h4>
<p>The example given above is a relatively elaborate TOCPO which needs
information from the prediction data to perform inversion. Many simpler
applications of target transformation do not need this information if
their inversion step is independent of this data. It is possible to
declare such a TOCPO using the <code>constant.invert</code> flag in
<code>makeCPOTargetOp()</code>. If <code>constant.invert</code> is set
to <code>TRUE</code>, the <code>cpo.train.invert</code> argument must be
explicitly set to <code>NULL</code>. <code>cpo.train</code> still needs
to have a <code>control.invert</code> argument; it is set to the value
returned by <code>cpo.train</code>.</p>
<p>The following example is a TOCPO for regression <code>Task</code>s
that centers target values during training. After prediction, the data
is inverted by adding the original mean of the training data to the
predictions. This inversion operation does not need any information
about the prediction data going in, so the TOCPO can be declared
<code>constant.invert</code>.</p>
<p>The <code>cpo.retrafo</code> function is also called when new
prediction data <em>with</em> a target column is transformed (as during
model validation). In that case, the mean of the <em>training data</em>
column is subtracted. Therefore the mean generated by
<code>cpo.train</code> needs to be used in <code>cpo.retrafo</code>
(i.e. the <code>control</code> value), not the mean of the
<code>target</code> data present.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>xmpRegCenter <span class="ot">=</span> <span class="fu">makeCPOTargetOp</span>(<span class="st">&quot;xmp.center&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">constant.invert =</span> <span class="cn">TRUE</span>,</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.train.invert =</span> <span class="cn">NULL</span>,  <span class="co"># necessary for constant.invert = TRUE</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">dataformat =</span> <span class="st">&quot;df.feature&quot;</span>,</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">properties.target =</span> <span class="st">&quot;regr&quot;</span>,</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.train =</span> <span class="cf">function</span>(data, target) {</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># control value is just the mean of the target column</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mean</span>(target[[<span class="dv">1</span>]])</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cf">function</span>(data, target, control) {</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># subtract mean from target column in retrafo</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    target[[<span class="dv">1</span>]] <span class="ot">=</span> target[[<span class="dv">1</span>]] <span class="sc">-</span> control</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    target</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.invert =</span> <span class="cf">function</span>(target, predict.type, control.invert) {</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    target <span class="sc">+</span> control.invert</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpRegCenter</span>()</span></code></pre></div>
<p>To illustrate this <code>CPO</code>, the following data is used:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>train.task <span class="ot">=</span> <span class="fu">subsetTask</span>(bh.task, <span class="dv">150</span><span class="sc">:</span><span class="dv">155</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskTargets</span>(train.task)</span></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>predict.task <span class="ot">=</span> <span class="fu">subsetTask</span>(bh.task, <span class="dv">156</span><span class="sc">:</span><span class="dv">160</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskTargets</span>(predict.task)</span></code></pre></div>
<p>The target column of the task after transformation has a mean of
0.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>trafd <span class="ot">=</span> train.task <span class="sc">%&gt;&gt;%</span> cpo</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskTargets</span>(trafd)</span></code></pre></div>
<p>When applying the retrafo <code>CPOTrained</code> to a new task, the
mean of the training task target column is subtracted.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskTargets</span>(predict.task)</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>retr <span class="ot">=</span> <span class="fu">retrafo</span>(trafd)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>predict.traf <span class="ot">=</span> predict.task <span class="sc">%&gt;&gt;%</span> retr</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskTargets</span>(predict.traf)</span></code></pre></div>
<p>When inverting a regression prediction, the mean of the training data
target column is added to the prediction.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">=</span> <span class="fu">train</span>(<span class="st">&quot;regr.lm&quot;</span>, trafd)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">=</span> <span class="fu">predict</span>(model, predict.traf)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>pred</span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">invert</span>(<span class="fu">inverter</span>(predict.traf), pred)</span></code></pre></div>
<p>Since <code>&quot;regr.lm&quot;</code> is translation invariant and
deterministic, the prediction equals the prediction made without
centering the target:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">=</span> <span class="fu">train</span>(<span class="st">&quot;regr.lm&quot;</span>, train.task)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="fu">predict</span>(model, predict.task)</span></code></pre></div>
<p>A special property of <code>constant.invert</code> TOCPOs is that
their retrafo <code>CPOTrained</code> can also be used for inversion.
This is the case since the tight coupling of inversion operation to the
data used to create the prediction is not necessary when the inversion
is actually independent of this data. This is indicated by
<code>getCPOTrainedCapability()</code> returning a vector with the
<code>&quot;invert&quot;</code> capability set to <code>1</code>. However, when
using the retrafo <code>CPOTrained</code> for inversion, the “truth”
column is absent from the inverted prediction.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getCPOTrainedCapability</span>(retr)</span></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">invert</span>(retr, pred)</span></code></pre></div>
</div>
<div id="functional-constant-invert-tocpo" class="section level4">
<h4>Functional Constant Invert TOCPO</h4>
<p>Just as above, <code>constant.invert</code> TOCPOs can be
<em>functional</em>. For this, the <code>cpo.train</code> function must
declare both a <code>cpo.retrafo</code> <em>and</em> a
<code>cpo.invert</code> variable which perform the requested operations.
These functions have no <code>control</code> or
<code>control.invert</code> parameter, and no parameters pertaining to
<code>par.set</code>.</p>
</div>
<div id="stateless-tocpo" class="section level4">
<h4>Stateless TOCPO</h4>
<p>Very simple target column operations that operate on a row-by-row
basis without needing information e.g. from training data, can be
declared as “stateless”. Similarly to <code>makeCPO()</code>, when
<code>cpo.train</code> parameter is set to <code>NULL</code>, no control
object is created for a <code>CPOTrained</code>. Furthermore, a
stateless TOCPO must always have <code>constant.invert</code> set as
well. Therefore, only <code>cpo.retrafo</code> and
<code>cpo.invert</code> are given as functions, both without a
<code>control</code> or <code>control.invert</code> argument. One
example is a TOCPO that log-transforms the target column of a regression
task, and exponentiates the predictions made from this during inversion.
(A better inversion would take the <code>&quot;se&quot;</code> prediction into
account, see <code>cpoLogTrafoRegr</code>.)</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>xmpLogRegr <span class="ot">=</span> <span class="fu">makeCPOTargetOp</span>(<span class="st">&quot;log.regr&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">constant.invert =</span> <span class="cn">TRUE</span>,</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">properties.target =</span> <span class="st">&quot;regr&quot;</span>,</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.train =</span> <span class="cn">NULL</span>, <span class="at">cpo.train.invert =</span> <span class="cn">NULL</span>,</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cf">function</span>(data, target) {</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    target[[<span class="dv">1</span>]] <span class="ot">=</span> <span class="fu">log</span>(target[[<span class="dv">1</span>]])</span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    target</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.invert =</span> <span class="cf">function</span>(target, predict.type) {</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">exp</span>(target)</span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpLogRegr</span>()</span></code></pre></div>
<p>The <code>CPO</code> takes the logarithm of the task target column
both during training and when using the retrafo
<code>CPOTrained</code>.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>trafd <span class="ot">=</span> train.task <span class="sc">%&gt;&gt;%</span> cpo</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskTargets</span>(trafd)</span></code></pre></div>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>retr <span class="ot">=</span> <span class="fu">retrafo</span>(trafd)</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>predict.traf <span class="ot">=</span> predict.task <span class="sc">%&gt;&gt;%</span> retr</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskTargets</span>(predict.traf)</span></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">=</span> <span class="fu">train</span>(<span class="st">&quot;regr.lm&quot;</span>, trafd)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">=</span> <span class="fu">predict</span>(model, predict.traf)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>pred</span></code></pre></div>
<p>Note that both the inverter <em>and</em> the retrafo
<code>CPOTrained</code> can be used for inversion, since a stateless
TOCPO also has <code>constant.invert</code> set. As above, when using
the retrafo <code>CPOTrained</code>, the truth column is absent from the
result.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">invert</span>(<span class="fu">inverter</span>(predict.traf), pred)</span></code></pre></div>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu">invert</span>(retr, pred)</span></code></pre></div>
</div>
</div>
<div id="makecpoextendedtargetop" class="section level3">
<h3><code>makeCPOExtendedTargetOp()</code></h3>
<p>Just as for FOCPOs, it is possible to declare a TOCPO while having
more direct control over what happens at which stage of training,
re-transformation, or inversion. In a TOCPO defined with
<code>makeCPOTargetOp()</code>, the <code>cpo.retrafo</code> and
<code>cpo.train.invert</code> functions are called automatically when
necessary during training and re-transformation.
<code>makeCPOExtendedTargetOp()</code> instead has a
<code>cpo.trafo</code> and a <code>cpo.retrafo</code> parameter, which
get called during the respective operation.</p>
<p><code>cpo.trafo</code> must be a function taking the same parameters
as <code>cpo.train</code> in <code>makeCPOTargetOp()</code>. Instead of
returning a control object, it must define a variable named
“<code>control</code>”, and a variable named
“<code>control.invert</code>”. The former is used as the
<code>control</code> argument of <code>cpo.retrafo</code>, the latter is
used as <code>control.invert</code> for <code>cpo.invert</code> when
using the inverter <code>CPOTrained</code> created during training. The
return value of <code>cpo.trafo</code> must be similar to the value
returned by <code>cpo.retrafo</code> in <code>makeCPOTargetOp()</code>:
it must be the modified data set or target, depending on
<code>dataformat</code>.</p>
<p><code>cpo.retrafo</code> must take the same parameters as in
<code>makeCPOTargetOp()</code>. It must declare a
<code>control.invert</code> variable that will be given to
<code>cpo.retrafo</code> when using the inverter <code>CPOTrained</code>
created during retransformation. Since <code>cpo.retrafo</code> is
always called during retrafo <code>CPOTrained</code> application, a
“target” column may or may not be present. If a target column is not
present, the <code>target</code> parameter of <code>cpo.retrafo</code>
is <code>NULL</code> and the return value of <code>cpo.retrafo</code> is
ignored; otherwise it must be the transformed <code>target</code> value
(which, as in <code>makeCPOTargetOp()</code>, can be a <code>Task</code>
or <code>data.frame</code> of <em>all</em> data if
<code>dataformat</code> is <code>&quot;task&quot;</code> or
<code>&quot;df.all&quot;</code>).</p>
<p><code>cpo.invert</code> works just as in
<code>makeCPOTargetOp()</code>.</p>
<p>The following is a nonsensical, synthetic example that adds
<code>1</code> to the target column of a regression <code>Task</code>
during initial training, subtracts <code>1</code> during retrafo
re-application and is a no-op during inversion.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>xmpSynCPO <span class="ot">=</span> <span class="fu">makeCPOExtendedTargetOp</span>(<span class="st">&quot;syn.cpo&quot;</span>,  <span class="co"># nolint</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">properties.target =</span> <span class="st">&quot;regr&quot;</span>,</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.trafo =</span> <span class="cf">function</span>(data, target) {</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.trafo ***</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    target[[<span class="dv">1</span>]] <span class="ot">=</span> target[[<span class="dv">1</span>]] <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>    control <span class="ot">=</span> <span class="st">&quot;control created in cpo.trafo&quot;</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>    control.invert <span class="ot">=</span> <span class="st">&quot;control.invert created in cpo.trafo&quot;</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    target</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.retrafo =</span> <span class="cf">function</span>(data, target, control) {</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** cpo.retrafo ***&quot;</span>, <span class="st">&quot;control is:&quot;</span>, <span class="fu">deparse</span>(control), <span class="at">sep =</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>    control.invert <span class="ot">=</span> <span class="st">&quot;control.invert created in cpo.retrafo&quot;</span></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(target)) {</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">&quot;target is non-NULL, performing transformation</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a>      target[[<span class="dv">1</span>]] <span class="ot">=</span> target[[<span class="dv">1</span>]] <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span>(target)</span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">cat</span>(<span class="st">&quot;target is NULL, no transformation (but control.invert was created)</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span>(<span class="cn">NULL</span>)  <span class="co"># is ignored.</span></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a>  <span class="at">cpo.invert =</span> <span class="cf">function</span>(target, control.invert, predict.type) {</span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a>    <span class="fu">cat</span>(<span class="st">&quot;*** invert ***&quot;</span>, <span class="st">&quot;control.invert is:&quot;</span>, <span class="fu">deparse</span>(control.invert),</span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a>      <span class="at">sep =</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)</span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a>    target</span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">xmpSynCPO</span>()</span></code></pre></div>
<p>For an “extended” TOCPO, only one of the transformation functions is
called in each invocation. Initial transformation calls
<code>cpo.trafo</code> and adds <code>1</code> to the targets; using the
<code>CPOTrained</code> for re-transformation calls
<code>cpo.retrafo</code> and subtracts <code>1</code>.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>trafd <span class="ot">=</span> train.task <span class="sc">%&gt;&gt;%</span> cpo</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskTargets</span>(trafd)</span></code></pre></div>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>retrafd <span class="ot">=</span> train.task <span class="sc">%&gt;&gt;%</span> <span class="fu">retrafo</span>(trafd)</span></code></pre></div>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskTargets</span>(retrafd)</span></code></pre></div>
<p>It is also possible to perform re-transformation with a
<code>data.frame</code> that does not include the target column. In that
case the <code>target</code> value given to <code>cpo.retrafo</code>
will be <code>NULL</code>, as reported by that function in this
example:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>retrafd <span class="ot">=</span> <span class="fu">getTaskData</span>(train.task, <span class="at">target.extra =</span> <span class="cn">TRUE</span>)<span class="sc">$</span>data <span class="sc">%&gt;&gt;%</span> <span class="fu">retrafo</span>(trafd)</span></code></pre></div>
<p>The <code>trafd</code> object has an inverter <code>CPOTrained</code>
attribute that was created by <code>cpo.trafo</code>, the
<code>retrafd</code> object has an inverter <code>CPOTrained</code>
attribute created by <code>cpo.retrafo</code> (necessarily). This is
made visible by the given example inverter function:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>inv <span class="ot">=</span> <span class="fu">invert</span>(<span class="fu">inverter</span>(trafd), <span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>)</span></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>inv <span class="ot">=</span> <span class="fu">invert</span>(<span class="fu">inverter</span>(retrafd), <span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>)</span></code></pre></div>
</div>
</div>
<div id="postscriptum" class="section level2">
<h2>Postscriptum</h2>
<p>As an aside, the <code>Learner</code> enhanced by
<code>xmpMetaLearn</code> seems to perform marginally better than either
<code>&quot;classif.svm&quot;</code> or <code>&quot;classif.logreg&quot;</code> on their own
for a large enough subset of <code>pid.task</code> (here resampled with
output suppressed).</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>learners <span class="ot">=</span> <span class="fu">list</span>(</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">logreg =</span> <span class="fu">makeLearner</span>(<span class="st">&quot;classif.logreg&quot;</span>),</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">svm =</span> <span class="fu">makeLearner</span>(<span class="st">&quot;classif.svm&quot;</span>),</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">cpo =</span> <span class="fu">xmpMetaLearn</span>(<span class="fu">makeLearner</span>(<span class="st">&quot;classif.logreg&quot;</span>)) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>      <span class="fu">makeLearner</span>(<span class="st">&quot;classif.svm&quot;</span>)</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="co"># suppress output of &#39;*** cpo.train ***&#39; etc.</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="fu">configureMlr</span>(<span class="at">show.info =</span> <span class="cn">FALSE</span>, <span class="at">show.learner.output =</span> <span class="cn">FALSE</span>)</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>perfs <span class="ot">=</span> <span class="fu">sapply</span>(learners, <span class="cf">function</span>(lrn) {</span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unname</span>(<span class="fu">replicate</span>(<span class="dv">20</span>, <span class="fu">resample</span>(lrn, pid.task, cv10)<span class="sc">$</span>aggr))</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a><span class="co"># reset mlr settings</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a><span class="fu">configureMlr</span>()</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a><span class="fu">boxplot</span>(perfs)</span></code></pre></div>
<p>P-Values of comparing the <code>CPOLearner</code> to both
<code>&quot;classif.logreg&quot;</code>, and <code>&quot;classif.svm&quot;</code>:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>pvals <span class="ot">=</span> <span class="fu">c</span>(</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">logreg =</span> <span class="fu">t.test</span>(perfs[, <span class="st">&quot;logreg&quot;</span>], perfs[, <span class="st">&quot;cpo&quot;</span>], <span class="st">&quot;greater&quot;</span>)<span class="sc">$</span>p.value, </span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">svm =</span> <span class="fu">t.test</span>(perfs[, <span class="st">&quot;svm&quot;</span>], perfs[, <span class="st">&quot;cpo&quot;</span>], <span class="st">&quot;greater&quot;</span>)<span class="sc">$</span>p.value</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">p.adjust</span>(pvals), <span class="dv">3</span>)</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
