<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Martin Binder" />

<meta name="date" content="2024-02-20" />

<title>First Steps (No Output)</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">First Steps (No Output)</h1>
<h4 class="author">Martin Binder</h4>
<h4 class="date">2024-02-20</h4>



<div id="cpo-vignette-navigation" class="section level4">
<h4>CPO Vignette Navigation</h4>
<ol style="list-style-type: decimal">
<li><a href="a_1_getting_started.html">1. First Steps</a> (compact
version)</li>
<li><a href="a_2_mlrCPO_core.html">mlrCPO Core</a> (<a href="z_2_mlrCPO_core_terse.html">compact version</a>)</li>
<li><a href="a_3_all_CPOs.html">CPOs Built Into mlrCPO</a> (<a href="z_3_all_CPOs_terse.html">compact version</a>)</li>
<li><a href="a_4_custom_CPOs.html">Building Custom CPOs</a> (<a href="z_4_custom_CPOs_terse.html">compact version</a>)</li>
</ol>
<h2>
Table of Contents
</h2>
<div id="TOC">
<ul>
<li>
<a href="#about-the-vignettes">About the Vignettes</a>
</li>
<li>
<a href="#what-is-mlrcpo">What is mlrCPO?</a>
<ul>
<li>
<a href="#what-is-preprocessing">What is Preprocessing</a>
</li>
</ul>
</li>
<li>
<a href="#preprocessing-operations">Preprocessing Operations</a>
</li>
<li>
<a href="#hyperparameters">Hyperparameters</a>
</li>
<li>
<a href="#retrafo">Retrafo</a>
</li>
<li>
<a href="#inverter">Inverter</a>
<ul>
<li>
<a href="#constant-inverters">Constant Inverters</a>
</li>
<li>
<a href="#general-inverters">General Inverters</a>
</li>
</ul>
</li>
<li>
<a href="#retrafoless-cpos">Retrafoless CPOs</a>
</li>
<li>
<a href="#cpo-learners">CPO Learners</a>
</li>
<li>
<a href="#cpo-tuning">CPO Tuning</a>
</li>
<li>
<a href="#syntactic-sugar">Syntactic Sugar</a>
</li>
<li>
<a href="#inspecting-cpos">Inspecting CPOs</a>
</li>
<li>
<a href="#special-cpos">Special CPOs</a>
<ul>
<li>
<a href="#nullcpo">NULLCPO</a>
</li>
<li>
<a href="#cpo-multiplexer">CPO Multiplexer</a>
</li>
<li>
<a href="#cpo-wrapper">CPO Wrapper</a>
</li>
<li>
<a href="#cbind-cpo">CBind CPO</a>
</li>
</ul>
</li>
<li>
<a href="#custom-cpos">Custom CPOs</a>
</li>
<li>
<a href="#summary">Summary</a>
</li>
</ul>
</div>
</div>
<div id="about-the-vignettes" class="section level2">
<h2>About the Vignettes</h2>
<p>Since <code>mlrCPO</code> is a package with some depth to it, it
comes with a few vignettes that each explain different aspects of its
operation. These are the current document (“First Steps”), offering a
short introduction and information on where to get started, “<a href="a_2_mlrCPO_core.html">mlrCPO Core</a>”, describing all the
functions and tools offered by <code>mlrCPO</code> that are independent
from specific <code>CPO</code>s, “<a href="a_3_all_CPOs.html">CPOs Built
Into mlrCPO</a>”, listing all <code>CPO</code>s included in the
<code>mlrCPO</code> package, and “<a href="a_4_custom_CPOs.html">Building Custom CPOs</a>”, describing the
process of creating new <code>CPO</code>s that offer new
functionality.</p>
<p>All vignettes also have a “compact version” with the R output
suppressed for readability. They are linked in the navigation section at
the top.</p>
<p>All vignettes assume that <code>mlrCPO</code> (and therefore its
requirement <code>mlr</code>) is installed successfully and loaded using
<code>library(&quot;mlrCPO&quot;)</code>. Help with installation is provided on
the <a href="https://github.com/mlr-org/mlrCPO">project’s GitHub
page</a>.</p>
</div>
<div id="what-is-mlrcpo" class="section level2">
<h2>What is mlrCPO?</h2>
<p>“Composable Preprocessing Operators”, “CPO”, are an extension for the
<a href="https://github.com/mlr-org/mlr">mlr</a> (“Machine Learning in
R”) project which present preprocessing operations in the form of R
objects. These CPO objects can be composed to form complex operations,
they can be applied to data sets, and can be attached to mlr
<code>Learner</code> objects to generate machine learning pipelines that
combine preprocessing and model fitting.</p>
<div id="what-is-preprocessing" class="section level3">
<h3>What is Preprocessing</h3>
<p>“Preprocessing”, as understood by <code>mlrCPO</code>, is any
manipulation of data used in a machine learning process to get it from
its form as found in the wild into a form more fitting for the machine
learning algorithm (“<code>Learner</code>”) used for model fitting. It
is important that the exact method of preprocessing is kept track of, to
be able to perform this method when the resulting model is used to make
predictions on new data. It is also important, when evaluating
preprocessing methods e.g. using <em>resampling</em>, that the
parameters of these methods are independent of the validation dataset
and only depend on the training data set.</p>
<p><code>mlrCPO</code> tries to support the user in all these aspects of
preprocessing:</p>
<ol style="list-style-type: decimal">
<li>By providing a large set of atomic preprocessing <code>CPO</code>s
that can perform many different operations. Operations that go beyond
the provided toolset can be implemented in custom
<code>CPO</code>s.</li>
<li>By using “<code>CPOTrained</code>” objects that represent the
preprocessing done on training data that should, in that way, be
re-applied to new prediction data.</li>
<li>By making it possible to combine preprocessing objects with
<code>mlr</code> “<code>Learner</code>” objects that represent the
entinre machine learning pipeline to be tuned and evaluated.</li>
</ol>
</div>
</div>
<div id="preprocessing-operations" class="section level2">
<h2>Preprocessing Operations</h2>
<p>At the centre of <code>mlrCPO</code> are “<code>CPO</code>” objects.
To get a <code>CPO</code> object, it is necessary to call a <em>CPO
Constructor</em>. A CPO Constructor sets up the parameters of a
<code>CPO</code> and provides further options for its behaviour.
Internally, CPO Constructors are <em>functions</em> that have a common
interface and a friendly printer method.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>cpoScale  <span class="co"># a cpo constructor</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>cpoAddCols</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cpoScale</span>(<span class="at">center =</span> <span class="cn">FALSE</span>)  <span class="co"># create a CPO object that scales, but does not center, data</span></span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cpoAddCols</span>(<span class="at">Sepal.Area =</span> Sepal.Length <span class="sc">*</span> Sepal.Width)  <span class="co">#  this would add a column</span></span></code></pre></div>
<p><code>CPO</code>s exist first to be <em>applied</em> to data. Every
<code>CPO</code> represents a certain data transformation, and this
transformation is performed when the <code>CPO</code> is applied. This
can be done using the <strong><code>applyCPO</code></strong> function,
or the <strong><code>%&gt;&gt;%</code></strong> operator.
<code>CPO</code>s can be applied to <code>data.frame</code> objects, and
to <code>mlr</code> “<code>Task</code>” objects.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="ot">=</span> iris[<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">51</span>, <span class="dv">52</span>, <span class="dv">102</span>, <span class="dv">103</span>), ]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(iris.demo <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoQuantileBinNumerics</span>())  <span class="co"># bin the data in below &amp; above median</span></span></code></pre></div>
<p>A useful feature of <code>CPO</code>s is that they can be
concatenated to form new operations. Two <code>CPO</code>s can be
combined using the <strong><code>composeCPO</code></strong> function or,
as before, the <strong><code>%&gt;&gt;%</code></strong> operator. When
two <code>CPO</code>s are combined, the product is a new
<code>CPO</code> that can itself be composed or applied. The result of a
composition represents the operation of first applying the first
<code>CPO</code> and then the second <code>CPO</code>. Therefore,
<code>data %&gt;&gt;% (cpo1 %&gt;&gt;% cpo2)</code> is the same as
<code>(data %&gt;&gt;% cpo1) %&gt;&gt;% cpo2</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># first create three quantile bins, then as.numeric() all columns to</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co"># get 1, 2 or 3 as the bin number</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>quantilenum <span class="ot">=</span> <span class="fu">cpoQuantileBinNumerics</span>(<span class="at">numsplits =</span> <span class="dv">3</span>) <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoAsNumeric</span>()</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> quantilenum</span></code></pre></div>
<p>The last example shows that it is sometimes not a good idea to have a
<code>CPO</code> affect the whole dataset. Therefore, when a
<code>CPO</code> is created, it is possible to choose what columns the
<code>CPO</code> should affect. The CPO Constructor has a variety of
parameters, starting with <code>affect.</code>, that can be used to
choose what columns the <code>CPO</code> operates on. To prevent
<code>cpoAsNumeric</code> from influencing the <code>Species</code>
column, we can thus do</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>quantilenum.restricted <span class="ot">=</span> <span class="fu">cpoQuantileBinNumerics</span>(<span class="at">numsplits =</span> <span class="dv">3</span>) <span class="sc">%&gt;&gt;%</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cpoAsNumeric</span>(<span class="at">affect.names =</span> <span class="st">&quot;Species&quot;</span>, <span class="at">affect.invert =</span> <span class="cn">TRUE</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> quantilenum.restricted</span></code></pre></div>
<p>A more convenient method in this case, however, is to use an
<code>mlr</code> “<code>Task</code>”, which keeps track of the target
column. “Feature Operation” <code>CPO</code>s (as all the ones shown) do
not influence the target column.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>demo.task <span class="ot">=</span> <span class="fu">makeClassifTask</span>(<span class="at">data =</span> iris.demo, <span class="at">target =</span> <span class="st">&quot;Species&quot;</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>result <span class="ot">=</span> demo.task <span class="sc">%&gt;&gt;%</span> quantilenum</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskData</span>(result)</span></code></pre></div>
</div>
<div id="hyperparameters" class="section level2">
<h2>Hyperparameters</h2>
<p>When performing preprocessing, it is sometimes necessary to change a
small aspect of a long preprocessing pipeline. Instead of having to
re-construct the whole pipeline, <code>mlrCPO</code> offers the
possibility to change <em>hyperparameters</em> of a <code>CPO</code>.
This makes it very easy e.g. for tuning of preprocessing in combination
with a machine learning algorithm.</p>
<p>Hyperparameters of <code>CPO</code>s can be manipulated in the same
way as they are manipulated for <code>Learners</code> in
<code>mlr</code>, using <strong><code>getParamSet</code></strong> (to
list the parameters), <strong><code>getHyperPars</code></strong> (to
list the parameter values), and
<strong><code>setHyperPars</code></strong> (to change these values). To
get the parameter set of a <code>CPO</code>, it is also possible to use
<strong>verbose printing</strong> using the <code>!</code> (exclamation
mark) operator.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">cpoScale</span>()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>cpo</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getHyperPars</span>(cpo)  <span class="co"># list of parameter names and values</span></span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getParamSet</span>(cpo)  <span class="co"># more detailed view of parameters and their type / range</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!</span>cpo  <span class="co"># equivalent to print(cpo, verbose = TRUE)</span></span></code></pre></div>
<p><code>CPO</code>s use copy semantics, therefore
<code>setHyperPars</code> creates a copy of a <code>CPO</code> that has
the changed hyperparameters.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>cpo2 <span class="ot">=</span> <span class="fu">setHyperPars</span>(cpo, <span class="at">scale.scale =</span> <span class="cn">FALSE</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>cpo2</span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> cpo  <span class="co"># scales and centers</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> cpo2 <span class="co"># only centers</span></span></code></pre></div>
<p>When chaining many <code>CPO</code>s, it is possible for the many
hyperparameters to lead to very cluttered <code>ParamSet</code>s, or
even for hyperparameter names to clash. <code>mlrCPO</code> has two
remedies for that.</p>
<p>First, any <code>CPO</code> also has an
<strong><code>id</code></strong> that is always prepended to the
hyperparameter names. It can be set during construction, using the
<code>id</code> parameter, or changed later using <code>setCPOId</code>.
The latter one only works on primitive, i.e. not compound,
<code>CPO</code>s. Set the <code>id</code> to <code>NULL</code> to use
the <code>CPO</code>’s hyperparameters without a prefix.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">cpoScale</span>(<span class="at">id =</span> <span class="st">&quot;a&quot;</span>) <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoScale</span>(<span class="at">id =</span> <span class="st">&quot;b&quot;</span>)  <span class="co"># not very useful example</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getHyperPars</span>(cpo)</span></code></pre></div>
<p>The second remedy against hyperparameter clashes is different
“exports” of hyperparameters: The hyperparameters that can be changed
using <code>setHyperPars</code>, i.e. that are <em>exported</em> by a
<code>CPO</code>, are a subset of the parameters of the
<code>CPOConstructor</code>. For each kind of <code>CPO</code>, there is
a standard set of parameters that are exported, but during construction,
it is possible to influence the parameters that actually get exported
via the <code>export</code> parameter. <code>export</code> can be one of
a set of standard export settings (among them “<code>export.all</code>”
and “<code>export.none</code>”) or a <code>character</code> vector of
the parameters to export.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>cpo <span class="ot">=</span> <span class="fu">cpoPca</span>(<span class="at">export =</span> <span class="fu">c</span>(<span class="st">&quot;center&quot;</span>, <span class="st">&quot;rank&quot;</span>))</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">getParamSet</span>(cpo)</span></code></pre></div>
</div>
<div id="retrafo" class="section level2">
<h2>Retrafo</h2>
<p>Manipulating data for preprocessing itself is relatively easy. A
challenge comes when one wants to integrate preprocessing into a
machine-learning pipeline: The same preprocessing steps that are
performed on the training data need to be performed on the new
prediction data. However, the transformation performed for prediction
often needs information from the training step. For example, if training
entail performing PCA, then for prediction, the data must not undergo
another PCA, instead it needs to be rotated by the <em>rotation
matrix</em> found by the training PCA. The process of obtaining the
rotation matrix will be called “training” the <code>CPO</code>, and the
object that contains the trained information is called
<code>CPOTrained</code>. For preprocessing operations that operate only
on <em>features</em> of a task (as opposed to the target column), the
<code>CPOTrained</code> will always be applied to new incoming data, and
hence be of class <code>CPORetrafo</code> and called a
“<strong>retrafo</strong>” object. To obtain this retrafo object, one
can use <strong><code>retrafo()</code></strong>. Retrafo objects can be
applied to data just as <code>CPO</code>s can, by using the
<code>%&gt;&gt;%</code> operator.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>transformed <span class="ot">=</span> iris.demo <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoPca</span>(<span class="at">rank =</span> <span class="dv">3</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>transformed</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>ret <span class="ot">=</span> <span class="fu">retrafo</span>(transformed)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>ret</span></code></pre></div>
<p>To show that <code>ret</code> actually represents the exact same
preprocessing operation, we can feed the first line of
<code>iris.demo</code> back to it, to verify that the transformation is
the same.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>iris.demo[<span class="dv">1</span>, ] <span class="sc">%&gt;&gt;%</span> ret</span></code></pre></div>
<p>We obviously would not have gotten there by feeding the first line to
<code>cpoPca</code> directly:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>iris.demo[<span class="dv">1</span>, ] <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoPca</span>(<span class="at">rank =</span> <span class="dv">3</span>)</span></code></pre></div>
<p><code>CPOTrained</code> objects associated with an object are
automatically chained when another <code>CPO</code> is applied. To
prevent this from happening, it is necessary to “clear” the retrafos and
<a href="#inverter">inverters</a> associated with the object using
<strong><code>clearRI()</code></strong>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>t2 <span class="ot">=</span> transformed <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoScale</span>()</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">retrafo</span>(t2)</span></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>t3 <span class="ot">=</span> <span class="fu">clearRI</span>(transformed) <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoScale</span>()</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">retrafo</span>(t3)</span></code></pre></div>
<p>Note that <code>clearRI</code> has no influence on the
<code>CPO</code> operations themselves, and the resulting data is the
same:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(t2, t3, <span class="at">check.attributes =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<p>It is also possible to chain <code>CPOTrained</code> object using
<code>composeCPO()</code> or <code>%&gt;&gt;%</code>. This can be useful
if the trafo chain loses access to the <code>retrafo</code> attribute
for some reason. In general, it is only recommended to compose
<code>CPOTrained</code> objects that were created in the same process
and in correct order, since they are usually closely associated with the
training data in a particular place within the preprocessing chain.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">retrafo</span>(transformed) <span class="sc">%&gt;&gt;%</span> <span class="fu">retrafo</span>(t3)  <span class="co"># is the same as retrafo(t2) above.</span></span></code></pre></div>
</div>
<div id="inverter" class="section level2">
<h2>Inverter</h2>
<p>So far only <code>CPO</code>s were introduced that change the feature
columns of a <code>Task</code>. (“Feature Operation
<code>CPO</code>s”–<em>FOCPO</em>s). There is another class of
<code>CPO</code>s, “Target Operation <code>CPO</code>s” or
<em>TOCPO</em>s, that can change a <code>Task</code>’s target
columns.</p>
<p>This comes at the cost of some complexity when performing prediction:
Since the training data that was ultimately fed into a
<code>Learner</code> had a transformed target column, the predictions
made by the resulting model will not be directly comparable to the
original target values. Consider <code>cpoLogTrafoRegr</code>, a
<code>CPO</code> that log-transforms the target variable of a regression
<code>Task</code>. The predictions made with a <code>Learner</code> on a
log-transformed target variable will be in log-space and need to be
exponentiated (or otherwise re-transformed). This inversion operation is
represented by an “<strong>inverter</strong>” object that is attached to
a transformation result similarly to a retrafo object, and can be
obtained using the <strong><code>inverter()</code></strong> function. It
is of class <code>CPOInverter</code>, a subclass of
<code>CPOTrained</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>iris.regr <span class="ot">=</span> <span class="fu">makeRegrTask</span>(<span class="at">data =</span> iris.demo, <span class="at">target =</span> <span class="st">&quot;Petal.Width&quot;</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>iris.logd <span class="ot">=</span> iris.regr <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoLogTrafoRegr</span>()</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskData</span>(iris.logd)  <span class="co"># log-transformed target &#39;Petal.Width&#39;</span></span></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>inv <span class="ot">=</span> <span class="fu">inverter</span>(iris.logd)  <span class="co"># inverter object</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>inv</span></code></pre></div>
<p>The inverter object is used by the <code>invert()</code> function
that inverts the prediction made by a model trained on the transformed
task, and re-transforms this prediction to fit the space of the original
target data. The inverter object caches the “truth” of the data being
inverted (<code>iris.logd</code>, in the example), so
<code>invert</code> can give information on the truth of the inverted
data.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>logmodel <span class="ot">=</span> <span class="fu">train</span>(<span class="st">&quot;regr.lm&quot;</span>, iris.logd)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">=</span> <span class="fu">predict</span>(logmodel, iris.logd)  <span class="co"># prediction on the task itself</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>pred</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">invert</span>(inv, pred)</span></code></pre></div>
<p>This procedure can also be done with new incoming data. In general,
more than just the <code>cpoLogTrafoRegr</code> operation could be done
on the <code>iris.regr</code> task in the example, so to perform the
complete preprocessing <em>and</em> inversion, one needs to use the
retrafo object as well. When applying the retrafo object, a new inverter
object is generated, which is specific to the exact new data that was
being retransformed:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>newdata <span class="ot">=</span> <span class="fu">makeRegrTask</span>(<span class="st">&quot;newiris&quot;</span>, iris[<span class="dv">7</span><span class="sc">:</span><span class="dv">9</span>, ], <span class="at">target =</span> <span class="st">&quot;Petal.Width&quot;</span>,</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">fixup.data =</span> <span class="st">&quot;no&quot;</span>, <span class="at">check.data =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># the retrafo does the same transformation(s) on newdata that were</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co"># done on the training data of the model, iris.logd. In general, this</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="co"># could be more than just the target log transformation.</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>newdata.transformed <span class="ot">=</span> newdata <span class="sc">%&gt;&gt;%</span> <span class="fu">retrafo</span>(iris.logd)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskData</span>(newdata.transformed)</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">=</span> <span class="fu">predict</span>(logmodel, newdata.transformed)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>pred</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># the inverter of the newly transformed data contains information specific</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="co"># to the newly transformed data. In the current case, that is just the</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"># new &quot;truth&quot; column for the new data.</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>inv.newdata <span class="ot">=</span> <span class="fu">inverter</span>(newdata.transformed)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="fu">invert</span>(inv.newdata, pred)</span></code></pre></div>
<div id="constant-inverters" class="section level3">
<h3>Constant Inverters</h3>
<p>The <code>cpoLogTrafoRegr</code> is a special case of TOCPO in that
its inversion operation is <em>constant</em>: It does not depend on the
new incoming data, so in theory it is not necessary to get a new
inverter object for every piece of data that is being transformed.
Therefore, it is possible to use the <em>retrafo</em> object for
inversion in this case. However, the “truth” column will not be
available in this case:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">invert</span>(<span class="fu">retrafo</span>(iris.logd), pred)</span></code></pre></div>
<p>Whether a retrafo object is capable of performing inversion can be
checked with the <strong><code>getCPOTrainedCapability()</code></strong>
function. It returns a vector with named elements <code>&quot;retrafo&quot;</code>
and <code>&quot;invert&quot;</code>, indicating whether a <code>CPOTrained</code>
is capable of performing retrafo or inversion. A <code>1</code>
indicates that the object can perform the action and has an effect, a
<code>0</code> indicates that the action would have no effect (but also
throws no error), and a <code>-1</code> means that the object is not
capable of performing the action.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getCPOTrainedCapability</span>(<span class="fu">retrafo</span>(iris.logd))  <span class="co"># can do both retrafo and inversion</span></span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getCPOTrainedCapability</span>(inv)  <span class="co"># a pure inverter, can not be used for retrafo</span></span></code></pre></div>
</div>
<div id="general-inverters" class="section level3">
<h3>General Inverters</h3>
<p>As an example of a <code>CPO</code> that does not have a constant
inverter, consider <code>cpoRegrResiduals</code>, wich fits a regression
model on training data and returns the residuals of this fit. When
performing prediction, the <code>invert</code> action is to add
predictions by the <code>CPO</code>’s model to the incoming predictions
made by a model trained on the residuals.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)  <span class="co"># for reproducibility</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>iris.resid <span class="ot">=</span> iris.regr <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoRegrResiduals</span>(<span class="st">&quot;regr.lm&quot;</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskData</span>(iris.resid)</span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>model.resid <span class="ot">=</span> <span class="fu">train</span>(<span class="st">&quot;regr.randomForest&quot;</span>, iris.resid)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>newdata.resid <span class="ot">=</span> newdata <span class="sc">%&gt;&gt;%</span> <span class="fu">retrafo</span>(iris.resid)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="fu">getTaskData</span>(newdata.resid)  <span class="co"># Petal.Width are now the residuals of lm model predictions</span></span></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">=</span> <span class="fu">predict</span>(model.resid, newdata.resid)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>pred</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># transforming this prediction back to compare</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="co"># it to the original &#39;Petal.Width&#39;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>inv.newdata <span class="ot">=</span> <span class="fu">inverter</span>(newdata.resid)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="fu">invert</span>(inv.newdata, pred)</span></code></pre></div>
</div>
</div>
<div id="retrafoless-cpos" class="section level2">
<h2>Retrafoless CPOs</h2>
<p>Besides <em>FOCPO</em>s and <em>TOCPO</em>s, there are also
“<em>Retrafoless</em>” <code>CPO</code>s (<em>ROCPO</em>s). These only
perform operation in the training part of a machine learning pipeline,
but in turn are the only <code>CPO</code>s that may change the number of
rows in a dataset. The goal of ROCPOs is to change the number of data
samples, but not to transform the data or target values themselves.
Examples of ROCPOs are <code>cpoUndersample</code>,
<code>cpoSmote</code>, and <code>cpoSample</code>.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>sampled <span class="ot">=</span> iris <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoSample</span>(<span class="at">size =</span> <span class="dv">3</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>sampled</span></code></pre></div>
<p>There is no retrafo or inverter associated with the result. Instead,
both of them are <a href="#nullcpo">NULLCPO</a></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">retrafo</span>(sampled)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="fu">inverter</span>(sampled)</span></code></pre></div>
</div>
<div id="cpo-learners" class="section level2">
<h2>CPO Learners</h2>
<p>Until now, the <code>CPO</code>s have been invoked explicitly to
manipulate data and get retrafo and inverter objects. It is good to be
aware of the data flows in a machine learning process involving
preprocessing, but <code>mlrCPO</code> makes it very easy to automatize
this. It is possible to <em>attach</em> a <code>CPO</code> to a
<code>Learner</code> using <strong><code>attachCPO</code></strong> or
the <code>%&gt;&gt;%</code>-operator. When a <code>CPO</code> is
attached to a <code>Learner</code>, a <code>CPOLearner</code> is
created. The <code>CPOLearner</code> performs the preprocessing
operation dictated by the <code>CPO</code> before training the
underlying model, and stores and uses the retrafo and inverter objects
necessary during prediction. It is possible to attach compound
<code>CPO</code>s, and it is possible to attach further
<code>CPO</code>s to a <code>CPOLearner</code> to extend the
preprocessing pipeline. Exported hyperparamters of a <code>CPO</code>
are also present in a <code>CPOLearner</code> and can be changed using
<code>setHyperPars</code>, as usual with other <code>Learner</code>
objects.</p>
<p>Recreating the pipeline from <a href="#general-inverters">General
Inverters</a> with a <code>CPOLearner</code> looks like the following.
Note the prediction <code>pred</code> made in the end is identical with
the one made above.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)  <span class="co"># for reproducibility</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>lrn <span class="ot">=</span> <span class="fu">cpoRegrResiduals</span>(<span class="st">&quot;regr.lm&quot;</span>) <span class="sc">%&gt;&gt;%</span> <span class="fu">makeLearner</span>(<span class="st">&quot;regr.randomForest&quot;</span>)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>lrn</span></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>model <span class="ot">=</span> <span class="fu">train</span>(lrn, iris.regr)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>pred <span class="ot">=</span> <span class="fu">predict</span>(model, newdata)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>pred</span></code></pre></div>
<p>It is possible to get the retrafo object from a model trained with a
<code>CPOLearner</code> using the <code>retrafo()</code> function. In
this example, it is identical with the <code>retrafo(iris.resid)</code>
gotten in the example in <a href="#general-inverters">General
Inverters</a>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">retrafo</span>(model)</span></code></pre></div>
</div>
<div id="cpo-tuning" class="section level2">
<h2>CPO Tuning</h2>
<p>Since the hyperparameters of a <code>CPO</code> are present in a
<code>CPOLearner</code>, is possible to tune hyperparameters of
preprocessing operations. It can be done using <code>mlr</code>’s
<strong><code>tuneParams()</code></strong> function and works
identically to tuning common <code>Learner</code>-parameters.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>icalrn <span class="ot">=</span> <span class="fu">cpoIca</span>() <span class="sc">%&gt;&gt;%</span> <span class="fu">makeLearner</span>(<span class="st">&quot;classif.logreg&quot;</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="fu">getParamSet</span>(icalrn)</span></code></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>ps <span class="ot">=</span> <span class="fu">makeParamSet</span>(</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">makeIntegerParam</span>(<span class="st">&quot;ica.n.comp&quot;</span>, <span class="at">lower =</span> <span class="dv">1</span>, <span class="at">upper =</span> <span class="dv">8</span>),</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">makeDiscreteParam</span>(<span class="st">&quot;ica.alg.typ&quot;</span>, <span class="at">values =</span> <span class="fu">c</span>(<span class="st">&quot;parallel&quot;</span>, <span class="st">&quot;deflation&quot;</span>)))</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="co"># shorter version using pSS:</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="co"># ps = pSS(ica.n.comp: integer[1, 8], ica.alg.typ: discrete[parallel, deflation])</span></span></code></pre></div>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tuneParams</span>(icalrn, pid.task, cv5, <span class="at">par.set =</span> ps,</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">control =</span> <span class="fu">makeTuneControlGrid</span>(),</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">show.info =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
</div>
<div id="syntactic-sugar" class="section level2">
<h2>Syntactic Sugar</h2>
<p>Besides the <code>%&gt;&gt;%</code> operator, there are a few related
operators which are short forms of operations that otherwise take more
typing.</p>
<ul>
<li><strong><code>%&lt;&lt;%</code></strong> is similar to
<code>%&gt;&gt;%</code> but works in the other direction.
<code>a %&gt;&gt;% b</code> is the same as
<code>b %&lt;&lt;% a</code>.</li>
<li><strong><code>%&lt;&gt;&gt;%</code> and
<code>%&lt;&lt;&lt;%</code></strong> are the <code>%&gt;&gt;%</code> or
<code>%&lt;&lt;%</code> operators, combined with assignment.
<code>a %&lt;&gt;&gt;% b</code> is the same as
<code>a = a %&gt;&gt;% b</code>. These operators perform the operations
on their right before they do the assignment, so it is not necessary to
use parentheses when writing
<code>a = a %&gt;&gt;% b %&gt;&gt;% c</code> as
<code>a %&lt;&gt;&gt;% b %&gt;&gt;% c</code>.</li>
<li><strong><code>%&gt;|%</code> and <code>%|&lt;%</code></strong> feed
data in a <code>CPO</code> and gets the <code>retrafo()</code>.
<code>data %&gt;|% a</code> is the same as
<code>retrafo(data %&gt;&gt;% a)</code>. The <code>%&gt;|%</code>
operator performs the operation on its right before getting the retrafo,
so it is not necessary to use parentheses when writing
<code>retrafo(data %&gt;&gt;% a %&gt;&gt;% b)</code> as
<code>data %&gt;|% a %&gt;&gt;% b</code>.</li>
</ul>
</div>
<div id="inspecting-cpos" class="section level2">
<h2>Inspecting CPOs</h2>
<p>As described before, it is possible to <em>compose</em>
<code>CPO</code>s to create relatively complex preprocessing pipelines.
It is therefore necessary to have tools to inspect a <code>CPO</code>
pipeline or related objects.</p>
<p>The first line of attack when inspecting a <code>CPO</code> is always
the <code>print</code> function. <code>print(x, verbose = TRUE)</code>
will often print more information about a <code>CPO</code> than the
ordinary print function. A shorthand alias for this is the exclamation
point “<strong><code>!</code></strong>”. When verbosely printing a
<code>CPOConstructor</code>, the transformation functions are shown.
When verbosely printing a <code>CPO</code>, the constituent elements are
separately printed, each showing their parameter sets.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>cpoAsNumeric  <span class="co"># plain print</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="sc">!</span>cpoAsNumeric  <span class="co"># verbose print</span></span></code></pre></div>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cpoScale</span>() <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoIca</span>()  <span class="co"># plain print</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="sc">!</span><span class="fu">cpoScale</span>() <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoIca</span>()  <span class="co"># verbose print</span></span></code></pre></div>
<p>When working with compound <code>CPO</code>s, it is sometimes
necessary to manipulate a <code>CPO</code> inside a compound
<code>CPO</code> pipeline. For this purpose, the
<strong><code>as.list()</code></strong> generic is implemented for both
<code>CPO</code> and <code>CPOTrained</code> for splitting a pipeline
into a list of the primitive elements. The inverse is
<strong><code>pipeCPO()</code></strong>, which takes a list of
<code>CPO</code> or <code>CPOTrained</code> and concatenates them using
<code>composeCPO()</code>.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu">as.list</span>(<span class="fu">cpoScale</span>() <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoIca</span>())</span></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pipeCPO</span>(<span class="fu">list</span>(<span class="fu">cpoScale</span>(), <span class="fu">cpoIca</span>()))</span></code></pre></div>
<p><code>CPOTrained</code> objects contain information about the retrafo
or inversion to be performed for a <code>CPO</code>. It is possible to
access this information using
<strong><code>getCPOTrainedState()</code></strong>. The “state” of a
<code>CPOTrained</code> object often contains a <code>$data</code> slot
with information about the expected input and output format
(“<code>ShapeInfo</code>”) of incoming data, a slot for each of its
hyperparameters, and a <code>$control</code> slot that is specific to
the <code>CPO</code> in question. The <code>cpoPca</code> state, for
example, contains the PCA rotation matrix and a vector for scaling and
centering. The contents of a state’s <code>$control</code> object are
described in a <code>CPO</code>’s help page.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>repca <span class="ot">=</span> <span class="fu">retrafo</span>(iris.demo <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoPca</span>())</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>state <span class="ot">=</span> <span class="fu">getCPOTrainedState</span>(repca)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>state</span></code></pre></div>
<p>It is even possible to change the “state” of a
<code>CPOTrained</code> and construct a new <code>CPOTrained</code>
using <strong><code>makeCPOTrainedFromState()</code></strong>. This is
fairly advanced usage and only recommended for users familiar with the
inner workings of the particular <code>CPO</code>. If we get familiar
with the <code>cpoPca</code> <code>CPO</code> using the
<code>!</code>-print (i.e. <code>!cpoPca</code>) to look at the retrafo
function, we notice that the <code>control$center</code> and
<code>control$scale</code> values are given to a call of
<code>scale()</code>. If we want to create a new <code>CPOTrained</code>
that does <em>not</em> perform centering or scaling during before
applying the rotation matrix, we can change these values.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>state<span class="sc">$</span>control<span class="sc">$</span>center <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>state<span class="sc">$</span>control<span class="sc">$</span>scale <span class="ot">=</span> <span class="cn">FALSE</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>nosc.repca <span class="ot">=</span> <span class="fu">makeCPOTrainedFromState</span>(cpoPca, state)</span></code></pre></div>
<p>Comparing this to the original “<code>repca</code>” retrafo shows
that the result of applying <code>repca</code> has generally smaller
values because of the centering.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> repca</span></code></pre></div>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> nosc.repca</span></code></pre></div>
</div>
<div id="special-cpos" class="section level2">
<h2>Special CPOs</h2>
<p>There is a large and growing variety of <code>CPO</code>s that
perform many different operations. It is advisable to browse through <a href="a_3_all_CPOs.html">CPOs Built Into mlrCPO</a> for an overview. To
get a list of all built-in <code>CPO</code>s, use
<strong><code>listCPO()</code></strong>. A few important or “meta”
<code>CPO</code>s that can be used to influence the behaviour of other
<code>CPO</code>s are described here.</p>
<div id="nullcpo" class="section level3">
<h3>NULLCPO</h3>
<p>The value associated with “no operation” is the <code>NULLCPO</code>
value. It is the neutral element of the <code>%&gt;&gt;%</code>
operations, and the value of <code>retrafo()</code> and
<code>inverter()</code> when there are otherwise no associated retrafo
or inverter values.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>NULLCPO</span></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(iris <span class="sc">%&gt;&gt;%</span> NULLCPO, iris)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="fu">cpoPca</span>() <span class="sc">%&gt;&gt;%</span> NULLCPO</span></code></pre></div>
</div>
<div id="cpo-multiplexer" class="section level3">
<h3>CPO Multiplexer</h3>
<p>The multiplexer makes it possible to combine many CPOs into one, with
an extra <code>selected.cpo</code> parameter that chooses between them.
This makes it possible to tune over many different tuner configurations
at once.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>cpm <span class="ot">=</span> <span class="fu">cpoMultiplex</span>(<span class="fu">list</span>(cpoIca, <span class="fu">cpoPca</span>(<span class="at">export =</span> <span class="st">&quot;export.all&quot;</span>)))</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="sc">!</span>cpm</span></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> <span class="fu">setHyperPars</span>(cpm, <span class="at">selected.cpo =</span> <span class="st">&quot;ica&quot;</span>, <span class="at">ica.n.comp =</span> <span class="dv">3</span>)</span></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> <span class="fu">setHyperPars</span>(cpm, <span class="at">selected.cpo =</span> <span class="st">&quot;pca&quot;</span>, <span class="at">pca.rank =</span> <span class="dv">3</span>)</span></code></pre></div>
</div>
<div id="cpo-wrapper" class="section level3">
<h3>CPO Wrapper</h3>
<p>A simple CPO with one parameter which gets applied to the data as
CPO. This is different from a multiplexer in that its parameter is free
and can take any value that behaves like a CPO. On the downside, this
does not expose the argument’s parameters to the outside.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>cpa <span class="ot">=</span> <span class="fu">cpoWrap</span>()</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="sc">!</span>cpa</span></code></pre></div>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> <span class="fu">setHyperPars</span>(cpa, <span class="at">wrap.cpo =</span> <span class="fu">cpoScale</span>())</span></code></pre></div>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> <span class="fu">setHyperPars</span>(cpa, <span class="at">wrap.cpo =</span> <span class="fu">cpoPca</span>())</span></code></pre></div>
<p>Attaching the cpo applicator to a learner gives this learner a “cpo”
hyperparameter that can be set to any CPO.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getParamSet</span>(<span class="fu">cpoWrap</span>() <span class="sc">%&gt;&gt;%</span> <span class="fu">makeLearner</span>(<span class="st">&quot;classif.logreg&quot;</span>))</span></code></pre></div>
</div>
<div id="cbind-cpo" class="section level3">
<h3>CBind CPO</h3>
<p><code>cbind</code> other CPOs as operation. The <code>cbinder</code>
makes it possible to build DAGs of CPOs that perform different
operations on data and paste the results next to each other. It is often
useful to combine <code>cpoCbind</code> with <code>cpoSelect</code> to
filter out columns that would otherwise be duplciated.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>scale <span class="ot">=</span> <span class="fu">cpoSelect</span>(<span class="at">pattern =</span> <span class="st">&quot;Sepal&quot;</span>, <span class="at">id =</span> <span class="st">&quot;first&quot;</span>) <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoScale</span>(<span class="at">id =</span> <span class="st">&quot;scale&quot;</span>)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>scale.pca <span class="ot">=</span> scale <span class="sc">%&gt;&gt;%</span> <span class="fu">cpoPca</span>()</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>cbinder <span class="ot">=</span> <span class="fu">cpoCbind</span>(scale, scale.pca, <span class="fu">cpoSelect</span>(<span class="at">pattern =</span> <span class="st">&quot;Petal&quot;</span>, <span class="at">id =</span> <span class="st">&quot;second&quot;</span>))</span></code></pre></div>
<p><code>cpoCbind</code> recognises that <code>&quot;scale&quot;</code> happens
before <code>&quot;pca&quot;</code>, but is also fed to the result directly. The
verbose print draws a (crude) ascii-art graph.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="sc">!</span>cbinder</span></code></pre></div>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>iris.demo <span class="sc">%&gt;&gt;%</span> cbinder</span></code></pre></div>
</div>
</div>
<div id="custom-cpos" class="section level2">
<h2>Custom CPOs</h2>
<p>Even though <code>CPO</code>s are very flexible and can be combined
in many ways, it may be necessary to create completely custom
<code>CPO</code>s. Custom CPOs can be created using the
<strong><code>makeCPO()</code></strong> and related functions. “<a href="a_4_custom_CPOs.html">Building Custom CPOs</a>” is a wide topic
which has its own vignette.</p>
</div>
<div id="summary" class="section level2">
<h2>Summary</h2>
<ul>
<li><strong><code>CPO</code></strong>s are built using
<strong><code>CPOConstructor</code></strong>s by calling them like
functions.</li>
<li>The available <code>CPOConstructors</code> can be found by using
<strong><code>listCPO()</code></strong> or consulting <a href="a_3_all_CPOs.html">the relevant vignette</a>.</li>
<li>Verbose printing of <code>CPO</code>s and many related objects is
available using the <strong><code>!</code></strong> (exclamation mark)
operator.</li>
<li><code>CPO</code>s export hyperparameters that are accessible using
<strong><code>getParamSet()</code></strong> and
<strong><code>getHyperPars()</code></strong>, and mutable using
<strong><code>setHyperPars()</code></strong>. Which parameters are
exported can be controlled using the
<strong><code>export</code></strong> parameter during construction.</li>
<li>They can be composed (<strong><code>composeCPO()</code></strong>),
applied to data (<strong><code>applyCPO()</code></strong>) and attached
to <code>Learner</code>s (<strong><code>attachCPO()</code></strong>)
using special functions for each of these operations, or using the
general <strong><code>%&gt;&gt;%</code></strong> operator.</li>
<li>There are three fundamental kinds of <code>CPO</code>:
<strong>FOCPO</strong> (Feature Operation <code>CPO</code>s),
<strong>TOCPO</strong> (Target Operation <code>CPO</code>s) and
<strong>ROCPO</strong> (Retrafoless <code>CPO</code>s). The first may
only change feature columns, the second only target columns. While the
last one may change both feature <em>and</em> target values and even the
number of rows of a dataset, it does so with the understanding that new
“prediction” data will not be transformed by it and is thus mainly
useful for subsampling.</li>
<li>Data that was transformed by a (non-Retrafoless) <code>CPO</code>
has a retrafo-<strong><code>CPOTrained</code></strong> object associated
with it that can be retrieved using
<strong><code>retrafo()</code></strong> and used to transform new
prediction data in similar way as the original training data.</li>
<li><code>CPOTrained</code> objects can themselves be composed using
<strong><code>composeCPO</code></strong> or
<strong><code>%&gt;&gt;%</code></strong>, although it is only
recommended to compose <code>CPOTrained</code> objects in the same order
as they were created, and only if they were created in the same
preprocessing pipeline.</li>
<li><code>CPOTrained</code> objects can be inspected using
<strong><code>getCPOTrainedState()</code></strong>, and re-built with
changed state using
<strong><code>makeCPOTrainedFromState()</code></strong>.</li>
<li>Data that was transformed by a <em>TOCPO</em> also has an
<em>inverter</em> associated with it, which can be retrieved using
<strong><code>inverter()</code></strong>. An inverter is also created
during application of a retrafo <code>CPOTrained</code>.</li>
<li>While <em>retrafo</em> <code>CPOTrained</code> are created during
training and used on every prediction data set, <em>inverter</em>
<code>CPOTrained</code> are created anew during each <code>CPO</code>
and retrafo-<code>CPOTrained</code> application and are closely
associated with the data that they were created with.</li>
<li><code>CPOTrained</code> objects associated with data are stored in
their “attributes” and are automatically chained when more
<code>CPO</code>s are applied. <strong><code>clearRI()</code></strong>
is used to remove the associated <code>CPOTrained</code> objects and
prevent this chaining.</li>
<li><code>CPO</code>s can be attached to <code>Learner</code>s to get
<strong><code>CPOLearner</code></strong>s which automatically transform
training <em>and</em> prediction data and perform prediction
inversion.</li>
<li><code>CPOLearner</code>s have the <code>Learner</code>’s
<em>and</em> the <code>CPO</code>’s hyperparameters and can thus be
manipulated using <strong><code>setHyperPars()</code></strong>, and can
be tuned using <strong><code>tuneParams()</code></strong>.</li>
<li>Notable <code>CPO</code>s are <strong><code>NULLCPO</code></strong>
(the neutral element of <code>%&gt;&gt;%</code>),
<strong><code>cpoMultiplex</code></strong>,
<strong><code>cpoWrap</code></strong>, and
<strong><code>cpoCbind</code></strong>.</li>
<li>It is possible to create custom <code>CPO</code>s using
<strong><code>makeCPO</code></strong> and similar functions. These are
described <a href="a_4_custom_CPOs.html">in their own vignette</a>.</li>
</ul>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
